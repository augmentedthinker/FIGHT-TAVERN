<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Dungeon Master's Chronicle</title>
    
    <!-- --- LIBRARIES --- -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons for Battle UI -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <!-- Socket.IO Client -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    
    <!-- Three.js Import Map -->
    <script type="importmap">
        { "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
            "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"
        }}
    </script>

    <!-- --- FONTS --- -->
    <link href="https://fonts.googleapis.com/css2?family=Alegreya:wght@400;700&family=Pirata+One&family=MedievalSharp&display=swap" rel="stylesheet">

    <!-- Tailwind Config for Battle Animations -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: { medieval: ['MedievalSharp', 'cursive'] },
                    animation: {
                        'shake': 'shake 0.5s cubic-bezier(.36,.07,.19,.97) both',
                        'pop': 'pop 0.3s ease-out forwards',
                        'pulse-glow': 'pulseGlow 2s infinite',
                    },
                    keyframes: {
                        shake: {
                            '10%, 90%': { transform: 'translate3d(-1px, 0, 0)' },
                            '20%, 80%': { transform: 'translate3d(2px, 0, 0)' },
                            '30%, 50%, 70%': { transform: 'translate3d(-4px, 0, 0)' },
                            '40%, 60%': { transform: 'translate3d(4px, 0, 0)' }
                        },
                        pop: {
                            '0%': { transform: 'scale(0.8)', opacity: '0' },
                            '100%': { transform: 'scale(1)', opacity: '1' }
                        },
                        pulseGlow: {
                            '0%, 100%': { opacity: '1', filter: 'brightness(1)' },
                            '50%': { opacity: '0.8', filter: 'brightness(1.2)' }
                        }
                    }
                }
            }
        }
    </script>

    <style>
        /* --- GLOBAL & RESET --- */
        body { margin: 0; padding: 0; overflow: hidden; background-color: black; font-family: 'Alegreya', serif; }
        body, #root, #gate-root, #sanctuary-wrapper, #title-screen, #cinematic-root { touch-action: none; overscroll-behavior: none; } 
        
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }

        .font-pirata { font-family: 'Pirata One', cursive; }
        .text-shadow-heavy { text-shadow: 0 4px 8px rgba(0,0,0,0.9), 0 1px 3px rgba(0,0,0,0.8); }

        /* --- CONTAINER VISIBILITY UTILS --- */
        .scene-container {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            display: none; 
        }
        .scene-container.active {
            display: block;
        }

        /* --- PART 0: TITLE SCREEN --- */
        #title-screen {
            position: absolute; inset: 0; z-index: 2000;
            background: url('TITLE.png') no-repeat center center fixed;
            background-size: cover;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            opacity: 1; transition: opacity 1s ease-in-out;
        }
        #title-screen.hidden-title { opacity: 0; pointer-events: none; }
        #title-screen::before {
            content: ""; position: absolute; inset: 0;
            background: rgba(0,0,0,0.3);
            z-index: -1;
        }
        
        .title-menu { display: flex; flex-direction: column; gap: 1.5rem; width: 100%; max-width: 300px; z-index: 10; margin-top: 10vh; }
        .title-btn {
            background: rgba(0,0,0,0.8); border: 2px solid #f59e0b; color: #f59e0b;
            padding: 1rem; font-family: 'Pirata One', cursive; font-size: 1.8rem;
            cursor: pointer; transition: all 0.3s; border-radius: 8px;
            text-transform: uppercase; letter-spacing: 2px;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }
        .title-btn:hover { background: #f59e0b; color: black; transform: scale(1.05); box-shadow: 0 0 25px rgba(245, 158, 11, 0.6); }
        .title-btn:disabled { border-color: #555; color: #555; cursor: not-allowed; transform: none; box-shadow: none; }

        /* --- PART 0.5: CINEMATIC ROOT --- */
        #cinematic-root {
            position: absolute; inset: 0; z-index: 1500;
            background: black;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            transition: opacity 0.8s ease;
        }
        #cinematic-root.active { display: flex; }
        .cinematic-bg {
            position: absolute; inset: 0;
            background-size: cover;
            background-position: center;
            opacity: 0;
            transition: opacity 1s ease;
            z-index: -1;
        }
        .cinematic-bg.visible { opacity: 1; }
        
        #cinematic-text-area {
            width: 80%;
            max-width: 800px;
            text-align: center;
            font-family: 'Alegreya', serif;
            font-size: 1.5rem;
            line-height: 1.8;
            color: #e2e8f0;
            text-shadow: 2px 2px 4px rgba(0,0,0,1);
            z-index: 5;
            padding: 2rem;
            background: rgba(0,0,0,0.2);
            border-radius: 12px;
        }
        
        .typewriter-text {
            display: inline;
        }

        .btn-cinematic-next {
            position: absolute;
            bottom: 10%;
            padding: 1rem 3rem;
            background: rgba(0,0,0,0.6);
            border: 2px solid #f59e0b;
            color: #f59e0b;
            font-family: 'Pirata One', cursive;
            font-size: 2rem;
            border-radius: 8px;
            cursor: pointer;
            z-index: 10;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(0,0,0,0.8);
            opacity: 0;
            pointer-events: none;
        }
        .btn-cinematic-next.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .btn-cinematic-next:hover {
            background: #f59e0b;
            color: black;
            box-shadow: 0 0 30px rgba(245, 158, 11, 0.6);
            transform: scale(1.1);
        }

        /* --- PART 1 (INTRO) STYLES --- */
        @keyframes rotate-phone {
            0%, 10% { transform: rotate(0deg); opacity: 1; }
            40%, 60% { transform: rotate(-90deg); opacity: 1; }
            90%, 100% { transform: rotate(-90deg); opacity: 0; }
        }

        /* --- PART 2 (THE GATES) SPECIFIC STYLES --- */
        #gate-root {
            background: url('Green-Red.png') no-repeat center center fixed;
            background-size: cover;
            color: #e2e8f0;
            z-index: 500;
        }
        #gate-root::before {
            content: "";
            position: absolute; top: 0; left: 0; right: 0; bottom: 0;
            background: radial-gradient(circle at center, rgba(0,0,0,0) 0%, rgba(0,0,0,0.6) 90%);
            pointer-events: none;
        }

        .dice-widget-container {
            position: relative;
            width: 320px;
            max-width: 90vw;
            height: 450px;
            max-height: 85vh;
            border-radius: 20px;
            overflow: hidden;
            background: #f1f5f9;
            box-shadow: 0 20px 40px rgba(0,0,0,0.6);
            display: flex;
            flex-direction: column;
        }
        .custom-scroll::-webkit-scrollbar { width: 6px; }
        .custom-scroll::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); }
        .custom-scroll::-webkit-scrollbar-thumb { background: rgba(245, 158, 11, 0.3); border-radius: 10px; }

        /* --- PART 3 (TAVERN) CSS VARIABLES & STYLES --- */
        :root {
            --amber: #f59e0b;
            --amber-glow: rgba(245, 158, 11, 0.6);
            --bg-dark: #000000;
            --dice-bg: #334155;
            --dice-floor: #f1f5f9;
            --dice-text-dark: #334155;
            --dice-text-light: #64748b;
            --dice-highlight: #3b82f6;
        }

        #sanctuary-wrapper {
            background-color: var(--bg-dark);
            color: #e0e0e0;
            z-index: 1000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        #sanctuary-wrapper.active { display: flex; }

        #game-container { position: relative; width: 100vw; height: 100vh; background: #000; overflow: hidden; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        #game-container::after { content: ""; position: absolute; inset: 0; background: radial-gradient(circle, transparent 50%, rgba(0,0,0,0.6) 100%); pointer-events: none; z-index: 5; }
        #scene-image { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; object-position: center center; transition: opacity 1s ease; opacity: 0; filter: brightness(0.8) contrast(1.1); z-index: 1; }
        #scene-image.visible { opacity: 1; }
        #top-title-container { position: absolute; top: 30px; left: 0; right: 0; text-align: center; z-index: 15; pointer-events: none; padding: 0 20px; }
        #scene-title { font-family: 'Pirata One', cursive; color: var(--amber); font-size: clamp(3rem, 6vw, 4.5rem); margin: 0; letter-spacing: 2px; text-shadow: 0 4px 10px rgba(0,0,0,1); opacity: 0; transition: opacity 1s ease; animation: flicker 5s infinite alternate ease-in-out; }
        @keyframes flicker { 0%, 100% { opacity: 1; text-shadow: 0 0 20px var(--amber-glow); } 50% { opacity: 0.95; text-shadow: 0 0 10px var(--amber); } }
        #character-hud { position: absolute; top: 30px; left: 30px; z-index: 50; background: rgba(0, 0, 0, 0.7); border: 1px solid var(--amber); padding: 15px 20px; border-radius: 8px; font-family: 'Pirata One', cursive; color: var(--amber); font-size: 1.3rem; display: flex; flex-direction: column; gap: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.5); backdrop-filter: blur(4px); min-width: 120px; }
        .stat-line { display: flex; justify-content: space-between; gap: 15px; }
        .stat-val { color: #fff; }
        .stat-mod { color: #aaa; font-size: 0.9rem; margin-left: 5px; }
        #choice-grid { position: absolute; bottom: 40px; display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap; opacity: 0; transition: opacity 0.5s ease; width: 100%; max-width: 95%; pointer-events: auto; z-index: 60; }
        #dialogue-area { position: absolute; bottom: 120px; width: 80%; max-width: 700px; background: rgba(10, 10, 10, 0.9); border: 2px solid var(--amber); padding: 20px; color: #ddd; font-size: 1.2rem; text-align: center; border-radius: 8px; z-index: 55; display: none; box-shadow: 0 0 20px rgba(0,0,0,0.8); }
        .btn-choice { background: rgba(0, 0, 0, 0.85); color: var(--amber); border: 1px solid rgba(245, 158, 11, 0.5); padding: 12px 24px; font-family: 'Pirata One', cursive; font-size: 1.4rem; cursor: pointer; transition: all 0.3s ease; letter-spacing: 1px; box-shadow: 0 4px 10px rgba(0,0,0,0.7); border-radius: 4px; }
        .btn-choice.ai-btn { border-color: #8b5cf6; color: #a78bfa; }
        .btn-choice.ai-btn:hover { background: #8b5cf6; color: white; box-shadow: 0 0 15px rgba(139, 92, 246, 0.6); }
        .btn-choice.mem-btn { border-color: #10b981; color: #34d399; }
        .btn-choice.mem-btn:hover { background: #10b981; color: white; box-shadow: 0 0 15px rgba(16, 185, 129, 0.6); }
        .btn-choice.battle-btn { border-color: #ef4444; color: #fca5a5; }
        .btn-choice.battle-btn:hover { background: #ef4444; color: white; box-shadow: 0 0 15px rgba(239, 68, 68, 0.6); }
        .btn-choice.offline-btn { border-color: #64748b; color: #94a3b8; }
        .btn-choice.offline-btn:hover { background: #64748b; color: white; }
        .btn-choice.gold-btn { border-color: #eab308; color: #fde047; }
        .btn-choice.gold-btn:hover { background: #ca8a04; color: white; box-shadow: 0 0 15px rgba(234, 179, 8, 0.6); }
        .btn-choice.sleep-btn { border-color: #60a5fa; color: #93c5fd; }
        .btn-choice.sleep-btn:hover { background: #2563eb; color: white; box-shadow: 0 0 20px rgba(37, 99, 235, 0.8); }
        
        .btn-choice:hover { background: var(--amber); color: black; box-shadow: 0 0 15px var(--amber-glow); transform: translateY(-3px); }

        /* LIVE BATTLE STYLES */
        .btn-choice.live-battle {
            border-color: #4ade80;
            color: #4ade80;
            box-shadow: 0 0 15px rgba(74, 222, 128, 0.4);
            animation: pulse-green 2s infinite;
        }
        .btn-choice.live-battle:hover {
            background: #22c55e;
            color: black;
            box-shadow: 0 0 25px rgba(74, 222, 128, 0.8);
        }
        @keyframes pulse-green {
            0% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(74, 222, 128, 0); }
            100% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0); }
        }

        #controls-left { position: absolute; bottom: 30px; left: 30px; z-index: 50; background: rgba(0,0,0,0.6); padding: 12px; border-radius: 50%; border: 1px solid rgba(245, 158, 11, 0.3); backdrop-filter: blur(4px); cursor: pointer; opacity: 0; transition: opacity 0.5s, transform 0.2s; pointer-events: none; display: flex; align-items: center; justify-content: center; }
        #controls-left.active { opacity: 1; pointer-events: auto; }
        #controls-left:hover { transform: scale(1.1); border-color: var(--amber); }
        #dice-toggle-btn { position: absolute; top: 30px; right: 30px; z-index: 100; background: rgba(0,0,0,0.6); border: 1px solid rgba(245, 158, 11, 0.5); color: var(--amber); width: 50px; height: 50px; border-radius: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(5px); transition: all 0.3s; box-shadow: 0 4px 10px rgba(0,0,0,0.5); }
        #dice-toggle-btn:hover { background: var(--amber); color: black; transform: scale(1.1); box-shadow: 0 0 20px var(--amber-glow); }
        #journal-btn { position: absolute; top: 30px; right: 90px; z-index: 100; background: rgba(0,0,0,0.6); border: 1px solid rgba(245, 158, 11, 0.5); color: var(--amber); width: 50px; height: 50px; border-radius: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(5px); transition: all 0.3s; box-shadow: 0 4px 10px rgba(0,0,0,0.5); }
        #journal-btn:hover { background: var(--amber); color: black; transform: scale(1.1); box-shadow: 0 0 20px var(--amber-glow); }
        
        /* Save / Menu Button */
        #menu-toggle-btn { position: absolute; top: 30px; right: 150px; z-index: 100; background: rgba(0,0,0,0.6); border: 1px solid rgba(245, 158, 11, 0.5); color: var(--amber); width: 50px; height: 50px; border-radius: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(5px); transition: all 0.3s; box-shadow: 0 4px 10px rgba(0,0,0,0.5); }
        #menu-toggle-btn:hover { background: var(--amber); color: black; transform: scale(1.1); box-shadow: 0 0 20px var(--amber-glow); }
        
        #journal-modal { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.9); z-index: 250; display: none; align-items: center; justify-content: center; backdrop-filter: blur(5px); opacity: 0; transition: opacity 0.3s; }
        #journal-modal.active { display: flex; opacity: 1; }
        #journal-content { width: 90%; max-width: 600px; max-height: 80vh; background: #1a1a1a; border: 2px solid var(--amber); border-radius: 8px; padding: 30px; overflow-y: auto; color: #ddd; font-family: 'Alegreya', serif; box-shadow: 0 0 30px rgba(245, 158, 11, 0.2); position: relative; }
        #journal-content h2 { font-family: 'Pirata One', cursive; color: var(--amber); text-align: center; margin-top: 0; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .journal-entry { margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px dashed #333; font-size: 1.1rem; line-height: 1.6; }
        .journal-entry:last-child { border-bottom: none; }
        
        /* Game Menu Modal */
        #game-menu-modal { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.9); z-index: 400; display: none; align-items: center; justify-content: center; backdrop-filter: blur(8px); opacity: 0; transition: opacity 0.3s; }
        #game-menu-modal.active { display: flex; opacity: 1; }
        #game-menu-content { width: 90%; max-width: 400px; background: #111; border: 2px solid var(--amber); border-radius: 12px; padding: 2rem; display: flex; flex-direction: column; gap: 1.5rem; }
        .menu-header { font-family: 'Pirata One', cursive; color: var(--amber); font-size: 2.5rem; text-align: center; margin-bottom: 0.5rem; }

        #memory-modal { position: fixed; inset: 0; background: #000; z-index: 300; display: none; flex-direction: column; opacity: 0; transition: opacity 0.5s ease; }
        #memory-modal.active { display: flex; opacity: 1; }
        #memory-header { width: 100%; padding: 15px 20px; background: rgba(0, 0, 0, 0.85); border-bottom: 2px solid var(--amber); display: flex; align-items: center; justify-content: space-between; box-sizing: border-box; z-index: 10; }
        #memory-title { font-family: 'Pirata One', cursive; color: var(--amber); font-size: 2.5rem; margin: 0; text-shadow: 0 0 15px rgba(245, 158, 11, 0.6); text-align: center; flex-grow: 1; }
        #memory-back-btn { background: transparent; border: 2px solid var(--amber); color: var(--amber); font-family: 'Alegreya', serif; font-size: 1.2rem; font-weight: bold; padding: 8px 20px; border-radius: 4px; cursor: pointer; transition: all 0.3s; text-transform: uppercase; letter-spacing: 1px; }
        #memory-back-btn:hover { background: var(--amber); color: #000; box-shadow: 0 0 15px var(--amber-glow); }
        #memory-img-container { flex: 1; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; overflow: hidden; position: relative; }
        #memory-img { width: 100%; height: 100%; object-fit: contain; display: block; }
        #memory-img[src=""] { display: none; }
        
        #dice-modal-overlay { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.85); backdrop-filter: blur(5px); z-index: 200; display: none; align-items: center; justify-content: center; opacity: 0; transition: opacity 0.3s ease; }
        #dice-modal-overlay.active { display: flex; opacity: 1; }
        #dice-widget { position: relative; width: 360px; height: 500px; border-radius: 24px; overflow: hidden; box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.8), 0 0 0 1px rgba(255, 255, 255, 0.1); background: var(--dice-floor); display: flex; flex-direction: column; transform: scale(0.9); transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        #dice-modal-overlay.active #dice-widget { transform: scale(1); }
        #widget-ui { position: absolute; inset: 0; z-index: 10; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; }
        .dice-header { position: relative; text-align: center; padding-bottom: 15px; border-bottom: 1px solid rgba(0,0,0,0.05); background: linear-gradient(to bottom, rgba(241, 245, 249, 0.95), transparent); }
        .dice-title { color: var(--dice-text-light); font-size: 0.75rem; letter-spacing: 2px; text-transform: uppercase; font-weight: 700; font-family: 'Segoe UI', sans-serif; }
        #color-picker-wrapper { position: absolute; top: 0; right: 0; pointer-events: auto; }
        #current-color-btn { width: 20px; height: 20px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); cursor: pointer; background: var(--dice-highlight); transition: transform 0.2s; padding: 0; }
        #current-color-btn:hover { transform: scale(1.1); }
        #color-dropdown { position: absolute; top: 30px; right: -5px; background: rgba(255, 255, 255, 0.95); backdrop-filter: blur(4px); padding: 8px; border-radius: 12px; box-shadow: 0 10px 25px -5px rgba(0,0,0,0.1); display: grid; grid-template-columns: 1fr 1fr; gap: 8px; opacity: 0; transform: translateY(-10px); pointer-events: none; transition: all 0.2s ease; border: 1px solid rgba(0,0,0,0.05); }
        #color-dropdown.open { opacity: 1; transform: translateY(0); pointer-events: auto; }
        .color-option { width: 24px; height: 24px; border-radius: 50%; border: 2px solid transparent; cursor: pointer; transition: transform 0.1s; }
        .color-option:hover { transform: scale(1.15); border-color: rgba(0,0,0,0.1); }
        #result-display { font-family: 'Segoe UI', sans-serif; font-size: 5rem; font-weight: 800; color: var(--dice-text-dark); text-align: center; -webkit-text-stroke: 3px var(--dice-floor); text-shadow: 0 5px 15px rgba(0,0,0,0.15); opacity: 0; transform: translate(-50%, -50%) scale(0.8); transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275); position: absolute; top: 45%; left: 50%; pointer-events: none; z-index: 20; }
        #result-display.visible { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        .controls-area { pointer-events: auto; background: rgba(255, 255, 255, 0.7); backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,0.8); border-radius: 16px; padding: 10px; display: flex; flex-direction: column; gap: 10px; }
        .dice-selector { display: flex; justify-content: space-between; background: rgba(0,0,0,0.05); border-radius: 12px; padding: 4px; }
        .die-btn { background: none; border: none; color: var(--dice-text-light); font-weight: bold; font-size: 0.8rem; padding: 8px 6px; cursor: pointer; border-radius: 8px; transition: all 0.2s; font-family: 'Segoe UI', sans-serif; }
        .die-btn:hover { color: var(--dice-text-dark); background: rgba(0,0,0,0.05); }
        .die-btn.display-none { display: none; }
        .die-btn.active { background: #ffffff; color: #0284c7; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        #roll-btn { background: var(--dice-highlight); border: none; padding: 12px; color: white; font-weight: bold; text-transform: uppercase; letter-spacing: 1px; border-radius: 12px; cursor: pointer; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2); transition: 0.1s; font-family: 'Segoe UI', sans-serif; }
        #roll-btn:active { transform: scale(0.98); }
        #roll-btn:disabled { filter: grayscale(1); opacity: 0.5; cursor: default; }
        #canvas-container { width: 100%; height: 100%; }
        #close-dice-btn { position: absolute; top: 20px; right: 20px; background: transparent; border: none; color: white; font-size: 2rem; cursor: pointer; z-index: 210; }
        #close-dice-btn:hover { color: var(--amber); }

        /* --- BATTLE WIDGET STYLES (New) --- */
        #fight-modal {
            position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 300;
            display: none; align-items: center; justify-content: center;
            font-family: 'MedievalSharp', cursive;
            backdrop-filter: blur(5px);
        }
        #fight-modal.active { display: flex; }

        .widget-container {
            width: 100%; max-width: 420px; height: 100%; max-height: 750px;
            background: #0f172a;
            border: 1px solid #334155;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            border-radius: 12px;
            display: flex; flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .battle-stage {
            flex: 1; display: flex; position: relative; background: #000;
        }

        .char-panel {
            flex: 1; position: relative; overflow: hidden;
            border-right: 1px solid rgba(0,0,0,0.5);
            transition: filter 0.3s ease;
        }
        .char-panel:last-child { border-right: none; }

        .char-img {
            width: 100%; height: 100%; object-fit: cover; 
            transition: transform 0.5s ease;
        }

        .active-turn .char-img { transform: scale(1.1); filter: brightness(1.1); }
        .inactive-turn .char-img { filter: grayscale(0.8) brightness(0.6); }

        .char-hud {
            position: absolute; bottom: 0; left: 0; right: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.95), transparent);
            padding: 20px 10px 10px 10px; z-index: 10;
        }

        .hp-track { width: 100%; height: 6px; background: #334155; border-radius: 3px; overflow: hidden; position: relative; margin-top: 4px; }
        .hp-fill { height: 100%; position: absolute; top: 0; left: 0; transition: width 0.3s; z-index: 2; }
        .hp-chip { height: 100%; position: absolute; top: 0; left: 0; background: white; transition: width 0.6s 0.3s; z-index: 1; }

        .control-deck {
            height: 110px; background: #1e293b;
            border-top: 1px solid #334155; border-bottom: 1px solid #334155;
            display: flex; align-items: center; justify-content: space-between;
            padding: 0 1rem; position: relative; z-index: 20;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        .die-btn-widget { 
            width: 80px; height: 80px; 
            cursor: pointer; transition: transform 0.2s; 
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.5));
        }
        .die-btn-widget:active { transform: scale(0.95); }
        .rolling svg { animation: roll 0.6s linear infinite; }
        @keyframes roll { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }

        .chat-section {
            height: 160px; background: #0f172a;
            display: flex; flex-direction: column;
        }
        .chat-scroll { flex: 1; overflow-y: auto; padding: 0.75rem; font-family: sans-serif; font-size: 0.8rem; }
        .chat-scroll::-webkit-scrollbar { width: 4px; }
        .chat-scroll::-webkit-scrollbar-thumb { background: #334155; }

        .btn-enter-gate {
            margin-top: 2rem;
            background: rgba(0,0,0,0.6);
            color: #f59e0b;
            border: 2px solid #f59e0b;
            padding: 12px 32px;
            font-family: 'Pirata One', cursive;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 0 15px rgba(245, 158, 11, 0.3);
            z-index: 200;
            pointer-events: auto;
            border-radius: 8px;
        }
        .btn-enter-gate:hover {
            background: #f59e0b;
            color: black;
            box-shadow: 0 0 25px rgba(245, 158, 11, 0.8);
            transform: scale(1.05);
        }
    </style>
</head>
<body>
    
    <!-- === PART 0: Title Screen === -->
    <div id="title-screen">
        <div class="title-menu">
            <button class="title-btn" onclick="startGame()">Start Game</button>
            <button class="title-btn" onclick="loadGame()">Load Game</button>
            <button class="title-btn" onclick="alert('Options Menu coming soon!')">Options</button>
        </div>
    </div>

    <!-- === PART 0.5: Post-Awaken Cinematic Transitions === -->
    <div id="cinematic-root" class="scene-container">
        <div id="cinematic-bg-storm" class="cinematic-bg" style="background-image: url('TownStorm.png');"></div>
        <div id="cinematic-bg-night" class="cinematic-bg" style="background-image: url('GateNight.png');"></div>
        <div id="cinematic-text-area">
            <p id="cinematic-text-content" class="typewriter-text"></p>
        </div>
        <button id="cinematic-next-btn" class="btn-cinematic-next" onclick="nextCinematic()">Next</button>
    </div>

    <!-- === PART 1: Intro (React) === -->
    <div id="root" class="scene-container"></div>

    <!-- === PART 2: The Gates (React + Three) === -->
    <div id="gate-root" class="scene-container"></div>

    <!-- === PART 3: Tavern (Vanilla JS) === -->
    <div id="sanctuary-wrapper">
        <div id="game-container">
            <img id="scene-image" src="" alt="Scene Background">
            <div id="top-title-container"><h1 id="scene-title"></h1></div>
            <div id="character-hud">
                <div class="stat-line">STR: <span id="str-val" class="stat-val">0</span></div>
                <div class="stat-line">DEX: <span id="dex-val" class="stat-val">0</span></div>
                <div class="stat-line">INT: <span id="int-val" class="stat-val">0</span></div>
                <div class="stat-line">CHA: <span id="cha-val" class="stat-val">0</span></div>
                <div class="stat-line" style="border-top: 1px solid #333; margin-top:5px; padding-top:5px; color:#ffd700;">GOLD: <span id="gold-val" class="stat-val" style="color:#ffd700;">5</span></div>
            </div>
            <div id="dialogue-area"><p id="dialogue-text">...</p></div>
            <div id="choice-grid"></div>
            
            <!-- Modified Back Button -->
            <div id="controls-left" onclick="goBack()" title="Previous Scene">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" width="32" height="32" stroke="#f59e0b">
                    <line x1="19" y1="12" x2="5" y2="12"></line>
                    <polyline points="12 19 5 12 12 5"></polyline>
                </svg>
            </div>
            
            <div id="menu-toggle-btn" onclick="toggleGameMenu()" title="Game Menu">
                <i data-lucide="menu" style="color:#f59e0b; width:24px; height:24px;"></i>
            </div>
            <div id="dice-toggle-btn" onclick="toggleDiceModal()" title="Open Dice Roller">
                <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M12.8 3.6a2 2 0 0 0-1.6 0l-7 4A2 2 0 0 0 3 9.4v5.2a2 2 0 0 0 1.2 1.8l7 4a2 2 0 0 0 1.6 0l7-4a2 2 0 0 0 1.2-1.8V9.4a2 2 0 0 0-1.2-1.8z"></path>
                    <path d="m12 11.3 7.8-4.5"></path>
                    <path d="m3 7.9 7.8 4.5v9"></path>
                    <path d="m13.2 21.4-.4-9 7.8-4.5"></path>
                </svg>
            </div>
            <div id="journal-btn" onclick="toggleJournal()" title="Open Story Journal">
                <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path>
                    <path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>
                </svg>
            </div>
        </div>
        
        <div id="journal-modal" onclick="toggleJournal()">
            <div id="journal-content" onclick="event.stopPropagation()">
                <h2>Your Tale</h2>
                <div id="story-log"></div>
                <button class="btn-choice" style="width:100%; margin-top:20px;" onclick="toggleJournal()">Close</button>
            </div>
        </div>

        <!-- NEW GAME MENU MODAL -->
        <div id="game-menu-modal" onclick="toggleGameMenu()">
            <div id="game-menu-content" onclick="event.stopPropagation()">
                <h2 class="menu-header">Chronicle Menu</h2>
                <button class="btn-choice" onclick="saveGame()">Save Progress</button>
                <button class="btn-choice" onclick="toggleGameMenu(); loadGame()">Load Progress</button>
                <button class="btn-choice" style="border-color:#ef4444; color:#ef4444;" onclick="returnToStartMenu()">Quit to Title</button>
                <button class="btn-choice" style="margin-top:1rem; font-size:1.1rem; opacity:0.8;" onclick="toggleGameMenu()">Resume Game</button>
            </div>
        </div>

        <div id="memory-modal">
            <div id="memory-header">
                <button id="memory-back-btn" onclick="closeMemory()">Back</button>
                <h2 id="memory-title">A Fading Memory</h2>
                <div style="width: 80px;"></div>
            </div>
            <div id="memory-img-container"><img id="memory-img" src="" alt="Loading memory..."></div>
        </div>
        <div id="dice-modal-overlay">
            <button id="close-dice-btn" onclick="toggleDiceModal()">&times;</button>
            <div id="dice-widget" onclick="event.stopPropagation()">
                <div id="widget-ui">
                    <div class="dice-header">
                        <div class="dice-title">Polyhedral Engine</div>
                        <div id="color-picker-wrapper">
                            <button id="current-color-btn" title="Change Dice Color"></button>
                            <div id="color-dropdown">
                                <button class="color-option" data-color="0x3b82f6" style="background: #3b82f6;"></button>
                                <button class="color-option" data-color="0xef4444" style="background: #ef4444;"></button>
                                <button class="color-option" data-color="0x22c55e" style="background: #22c55e;"></button>
                                <button class="color-option" data-color="0xa855f7" style="background: #a855f7;"></button>
                                <button class="color-option" data-color="0xeab308" style="background: #eab308;"></button>
                                <button class="color-option" data-color="0x334155" style="background: #334155;"></button>
                            </div>
                        </div>
                    </div>
                    <div id="result-display">20</div>
                    <div class="controls-area">
                        <div class="dice-selector">
                            <button class="die-btn" id="btn-d4" data-sides="4">D4</button>
                            <button class="die-btn" id="btn-d6" data-sides="6">D6</button>
                            <button class="die-btn" id="btn-d8" data-sides="8">D8</button>
                            <button class="die-btn" id="btn-d10" data-sides="10">D10</button>
                            <button class="die-btn" id="btn-d12" data-sides="12">D12</button>
                            <button class="die-btn active" id="btn-d20" data-sides="20">D20</button>
                        </div>
                        <button id="roll-btn">Roll Dice</button>
                    </div>
                </div>
                <div id="canvas-container"></div>
            </div>
        </div>
    </div>

    <!-- FIGHT WIDGET MODAL WRAPPER -->
    <div id="fight-modal">
        <div id="lobby-panel" class="z-10 widget-container items-center justify-center p-8 text-center animate-pop h-auto min-h-[500px]">
            <button onclick="toggleFightModal()" class="absolute top-2 right-2 text-slate-500 hover:text-white"><i data-lucide="x" class="w-6 h-6"></i></button>
            <i data-lucide="beer" class="w-16 h-16 text-yellow-600 mb-4 mx-auto"></i>
            <h1 class="text-3xl font-bold text-yellow-500 mb-2">THE FIGHTING TAVERN</h1>
            <div class="bg-slate-800/80 rounded-lg p-4 w-full mb-6 border border-slate-600">
                <div class="text-xs uppercase text-slate-400 font-bold mb-1 tracking-widest">Tavern Status</div>
                <div id="lobby-status-text" class="text-lg text-white font-bold animate-pulse-glow">Connecting...</div>
                <div id="lobby-count" class="text-xs text-slate-500 mt-1"></div>
            </div>
            <div id="lobby-actions" class="w-full space-y-3"></div>
            <div id="challenge-modal" class="hidden absolute inset-0 bg-black/90 flex flex-col items-center justify-center p-6 z-50 animate-pop">
                <h2 class="text-2xl text-yellow-500 font-bold mb-2">CHALLENGE!</h2>
                <p class="text-slate-300 text-sm mb-6">A rival warrior wants to fight.</p>
                <button onclick="app.acceptChallenge()" class="w-full bg-red-600 hover:bg-red-500 text-white py-4 rounded-lg font-bold mb-3 animate-pulse">ACCEPT BATTLE</button>
                <div class="text-xs text-slate-500">Wait to decline...</div>
            </div>
        </div>
        <div id="game-widget" class="widget-container hidden animate-pop">
            <div class="flex justify-between items-center px-3 py-2 bg-slate-900/90 border-b border-slate-700 z-30">
                <div class="flex items-center gap-2">
                    <i data-lucide="swords" class="w-4 h-4 text-yellow-500"></i>
                    <div id="role-alert" class="text-xs font-bold text-slate-300 uppercase tracking-wider">Loading...</div>
                </div>
                <div class="flex items-center gap-3">
                    <button onclick="battle.resetGame()" class="text-slate-500 hover:text-yellow-400"><i data-lucide="rotate-ccw" class="w-4 h-4"></i></button>
                    <button onclick="toggleFightModal()" class="text-slate-500 hover:text-white"><i data-lucide="log-out" class="w-4 h-4"></i></button>
                </div>
            </div>
            <div class="battle-stage">
                <div id="hero-card" class="char-panel group">
                    <img id="hero-img" src="" class="char-img" alt="Warrior">
                    <div class="char-hud">
                        <div class="flex justify-between text-xs font-bold text-blue-300 mb-1">
                            <span class="drop-shadow-md">WARRIOR</span> <span id="hero-hp-text">50/50</span>
                        </div>
                        <div class="hp-track">
                            <div id="hero-bar" class="hp-fill bg-blue-500" style="width: 100%"></div>
                            <div id="hero-chip" class="hp-chip" style="width: 100%"></div>
                        </div>
                    </div>
                </div>
                <div id="enemy-card" class="char-panel group">
                    <img id="enemy-img" src="" class="char-img" alt="Ogre">
                    <div class="char-hud">
                        <div class="flex justify-between text-xs font-bold text-red-300 mb-1">
                            <span class="drop-shadow-md">OGRE</span> <span id="enemy-hp-text">45/45</span>
                        </div>
                        <div class="hp-track">
                            <div id="enemy-bar" class="hp-fill bg-red-500" style="width: 100%"></div>
                            <div id="enemy-chip" class="hp-chip" style="width: 100%"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="control-deck">
                <div class="flex-1 text-left pr-4">
                    <div class="text-[10px] text-slate-500 uppercase tracking-widest font-bold">Battle Log</div>
                    <div id="action-log" class="text-sm font-bold text-slate-200 truncate leading-tight">Roll for initiative...</div>
                    <div id="math-log" class="text-[10px] font-mono text-yellow-600/80 h-3 leading-none mt-1"></div>
                </div>
                <div id="d20-btn" class="die-btn-widget" onclick="battle.sendAttack()">
                    <svg viewBox="0 0 100 100" class="w-full h-full overflow-visible">
                        <path d="M50 5 L92 28 L92 72 L50 95 L8 72 L8 28 Z" class="fill-slate-800 stroke-slate-600 stroke-2 transition-colors" id="die-bg"/>
                        <text x="50" y="62" text-anchor="middle" class="fill-slate-500 font-sans font-black text-2xl select-none" id="die-text">20</text>
                    </svg>
                </div>
            </div>
            <div class="chat-section">
                <div id="chat-messages" class="chat-scroll space-y-1.5">
                    <div class="text-slate-600 text-center italic text-xs mt-1 opacity-50">-- Tavern Chat --</div>
                </div>
                <form onsubmit="battle.sendChat(event)" class="p-2 bg-slate-950 flex gap-2 border-t border-slate-800">
                    <input id="chat-input" class="flex-1 bg-slate-900 border border-slate-700 rounded px-3 py-2 text-xs text-white focus:outline-none focus:border-yellow-600 placeholder-slate-600" placeholder="Type your message..." autocomplete="off">
                    <button type="submit" class="bg-slate-800 hover:bg-slate-700 text-white rounded px-3 transition-colors"><i data-lucide="send" class="w-4 h-4"></i></button>
                </form>
            </div>
            <div id="overlay" class="absolute inset-0 z-50 bg-black/95 flex flex-col items-center justify-center hidden p-6 text-center animate-pop">
                <i id="overlay-icon" data-lucide="skull" class="w-16 h-16 text-slate-700 mb-4"></i>
                <h1 class="text-4xl text-yellow-500 font-bold mb-2 tracking-tight" id="overlay-title">GAME OVER</h1>
                <p class="text-slate-400 mb-8 text-sm max-w-[200px]" id="overlay-sub">The battle has ended.</p>
                <button id="overlay-btn" onclick="battle.resetGame()" class="px-8 py-3 bg-red-900 border border-red-600 rounded-lg text-white font-bold hover:bg-red-800 transition-transform active:scale-95 shadow-lg shadow-red-900/20">RETURN TO TAVERN</button>
            </div>
        </div>
    </div>

    <!-- === LOGIC: TRANSITION UTILS === -->
    <script>
        let cinematicStage = 0;
        let isTyping = false;
        let sceneHistory = [];
        
        const CINEMATIC_SCRIPTS = [
            "Darkness... heavy and suffocating. Your lungs burn with every shallow breath. How many days has it been? Three? Four? The memory of your name is a flickering candle in a gale. Your feet are no longer part of you—only numb stumps dragging through frozen slush. You are a hollow shell, driven by a primal urge to simply... survive.",
            "Then, through the blinding curtain of the storm, a silhouette. Haven’s Keep. It stands atop the crag like a jagged tooth, its stone walls defiant against the lightning. For a moment, hope is a cruel joke. It is so far, and you are so small. But the wind howls a warning: stay here, and the frost will claim your bones before the dawn.",
            "You reach the threshold. The iron-bound gates are cold as death itself. The storm screams at your back, a predator sensing its prey is cornered. Your strength is gone. Your vision blurs at the edges as the world tilts. This is it. One final effort to make your presence known, or the blizzard will be your shroud..."
        ];

        function typeWriter(text, i, callback) {
            if (i < text.length) {
                document.getElementById("cinematic-text-content").innerHTML = text.substring(0, i + 1);
                isTyping = true;
                setTimeout(() => typeWriter(text, i + 1, callback), 30);
            } else {
                isTyping = false;
                if (callback) callback();
            }
        }

        window.startPostIntroCinematic = () => {
            document.getElementById('root').classList.remove('active');
            setTimeout(() => {
                document.getElementById('cinematic-root').classList.add('active');
                cinematicStage = 0;
                updateCinematicView();
            }, 500);
        };

        function updateCinematicView() {
            const nextBtn = document.getElementById('cinematic-next-btn');
            const bgStorm = document.getElementById('cinematic-bg-storm');
            const bgNight = document.getElementById('cinematic-bg-night');
            const textContent = document.getElementById('cinematic-text-content');
            
            nextBtn.classList.remove('visible');
            textContent.innerHTML = "";
            
            bgStorm.classList.remove('visible');
            bgNight.classList.remove('visible');
            
            if (cinematicStage === 1) bgStorm.classList.add('visible');
            if (cinematicStage === 2) bgNight.classList.add('visible');
            
            typeWriter(CINEMATIC_SCRIPTS[cinematicStage], 0, () => {
                nextBtn.classList.add('visible');
            });
        }

        function nextCinematic() {
            if (isTyping) return;
            cinematicStage++;
            if (cinematicStage >= CINEMATIC_SCRIPTS.length) {
                document.getElementById('cinematic-root').classList.remove('active');
                setTimeout(() => {
                    loadScene('exterior', true);
                    document.getElementById('gate-root').classList.add('active');
                    window.dispatchEvent(new Event('resize'));
                }, 500);
            } else {
                updateCinematicView();
            }
        }

        window.transitionIntroToGate = () => {
            window.startPostIntroCinematic();
        };

        window.transitionGateToTavern = () => {
            document.getElementById('gate-root').classList.remove('active');
            const sanctuary = document.getElementById('sanctuary-wrapper');
            sanctuary.classList.add('active');
            window.dispatchEvent(new Event('resize'));
        };

        function resetAllData() {
            // Full Reset Logic
            sceneHistory = [];
            currentSceneKey = 'hub';
            Object.assign(characterStats, { STR: 0, DEX: 0, INT: 0, CHA: 0, GOLD: 5 });
            Object.assign(gameStateFlags, { hasRoom: false, hasEaten: false, wasRescued: false });
            Object.keys(questLog).forEach(k => questLog[k] = 'pending');
            Object.keys(questMemories).forEach(k => questMemories[k] = null);
            document.getElementById('story-log').innerHTML = '';
            
            // Reset UI labels
            ['STR','DEX','INT','CHA'].forEach(s => {
                document.getElementById(s.toLowerCase() + '-val').innerText = '0';
            });
            updateGoldUI();
        }

        function startGame() {
            resetAllData();
            document.getElementById('title-screen').classList.add('hidden-title');
            setTimeout(() => {
                document.getElementById('title-screen').style.display = 'none';
                document.getElementById('root').classList.add('active');
            }, 1000);
        }

        function returnToStartMenu() {
            toggleGameMenu();
            resetAllData();
            const sanctuary = document.getElementById('sanctuary-wrapper');
            sanctuary.classList.remove('active');
            document.getElementById('title-screen').style.display = 'flex';
            setTimeout(() => {
                document.getElementById('title-screen').classList.remove('hidden-title');
            }, 100);
        }

        function toggleGameMenu() {
            const menu = document.getElementById('game-menu-modal');
            menu.classList.toggle('active');
            if (menu.classList.contains('active')) {
                menu.style.display = 'flex';
                if(window.lucide) window.lucide.createIcons();
            } else {
                setTimeout(() => { menu.style.display = 'none'; }, 300);
            }
        }

        function saveGame() {
            const saveData = {
                stats: characterStats,
                quests: questLog,
                flags: gameStateFlags,
                memories: questMemories,
                log: document.getElementById('story-log').innerHTML,
                scene: currentSceneKey || 'hub'
            };
            localStorage.setItem('roomStew_saveData', JSON.stringify(saveData));
            
            const menuBtn = document.querySelector('#game-menu-content button');
            const originalText = menuBtn.innerText;
            menuBtn.innerText = "Game Saved!";
            menuBtn.style.color = "#4ade80";
            setTimeout(() => {
                menuBtn.innerText = originalText;
                menuBtn.style.color = "";
                toggleGameMenu();
            }, 1000);
        }

        function loadGame() {
            const raw = localStorage.getItem('roomStew_saveData');
            if(!raw) { alert("No save game found!"); return; }
            const data = JSON.parse(raw);
            Object.assign(characterStats, data.stats);
            Object.assign(questLog, data.quests);
            Object.assign(gameStateFlags, data.flags);
            Object.assign(questMemories, data.memories);
            document.getElementById('story-log').innerHTML = data.log;
            updateGoldUI();
            const uiStats = { STR: document.getElementById('str-val'), DEX: document.getElementById('dex-val'), INT: document.getElementById('int-val'), CHA: document.getElementById('cha-val') };
            for(let s of ['STR','DEX','INT','CHA']) {
                const val = characterStats[s];
                const mod = Math.floor((val-10)/2);
                uiStats[s].innerHTML = `${val} <span class="stat-mod">(${mod>=0?'+':''}${mod})</span>`;
            }
            document.getElementById('title-screen').classList.add('hidden-title');
            setTimeout(() => {
                document.getElementById('title-screen').style.display = 'none';
                document.getElementById('sanctuary-wrapper').classList.add('active');
                sceneHistory = []; 
                loadScene(data.scene || 'hub');
            }, 1000);
        }
    </script>

    <!-- === LOGIC: Part 1 (Intro) === -->
    <script type="text/babel">
        const { useState, useEffect, useRef } = React;
        const STORY_STEPS = [
            { id: 'opening', src: '', color: 'from-black to-zinc-900', title: "Greetings", narration: "Greetings, traveler. You’ve wandered far to find this seat by my hearth. Let us pull back the veil and reveal the game we are about to play." },
            { id: 'dm-visible', src: 'DMmagic.png', color: 'from-purple-900 to-indigo-900', title: "The Voice in the Dark", narration: "I am your Dungeon Master, the architect of your triumphs and the grinning devil on your shoulder. I weave the \"invisible architecture\" of this journey, ensuring that every choice you make has a profound consequence." },
            { id: 'the-map', src: 'map.png', color: 'from-amber-900 to-orange-900', title: "The Eye of the Storm", narration: "Look upon the map. Haven’s Keep is the center. It is the \"safe harbor\" in a sea of chaos, and it is exactly where your story begins." },
            { id: 'dice-table', src: 'dice.png', color: 'from-blue-900 to-slate-900', title: "The Engines of Fate", narration: "To navigate this world, you must master these Tools of Fate. These many-sided dice determine how hard you hit or how deep the world bites back." },
            { id: 'd20-squirrels', src: 'dice20.png', color: 'from-emerald-900 to-teal-900', title: "The Die of Destiny", narration: "But this—the d20—is the most important object in your universe. It decides if you meet the Difficulty Class (DC) required to stay alive." },
            { id: 'dm-fading', src: 'DMswirls.png', color: 'from-gray-900 to-black', title: "The Threshold of Haven", narration: "You stumble through the dark, the air tasting of ozone and wet earth, until the silhouette of Haven’s Keep looms out of the deluge like a jagged tooth. You are at your breaking point." }
        ];

        function ImageWithFallback({ src, fallbackColor }) {
            const [error, setError] = useState(false);
            if (error || !src) return <div className={`w-full h-full bg-gradient-to-br ${fallbackColor}`} />;
            return <img src={src} alt="" className="w-full h-full object-cover" onError={() => setError(true)} />;
        }

        function IntroApp() {
            const [progress, setProgress] = useState(0);
            const [isPortrait, setIsPortrait] = useState(false);
            
            useEffect(() => {
                const check = () => setIsPortrait(window.innerHeight > window.innerWidth);
                check(); window.addEventListener('resize', check); return () => window.removeEventListener('resize', check);
            }, []);

            const handleWheel = (e) => {
                if(isPortrait) return;
                setProgress(prev => Math.min(Math.max(prev + e.deltaY * 0.002, 0), STORY_STEPS.length - 1));
            };

            const snapToNearest = (idx) => setProgress(idx);

            return (
                <div className="fixed inset-0 bg-black overflow-hidden font-serif select-none" onWheel={handleWheel}>
                    {isPortrait && <div className="fixed inset-0 z-50 bg-black flex items-center justify-center p-8 text-amber-500 font-pirata text-2xl text-center">Rotate Device to Begin</div>}
                    
                    {!isPortrait && (
                        <div className="absolute inset-0 w-full h-full">
                            {STORY_STEPS.map((step, index) => {
                                const rel = progress - index;
                                if (rel < -1 || rel > 1) return null;
                                
                                const imgOpacity = 1 - Math.abs(rel);
                                const scale = 1 + (rel * 0.2);
                                const isCurrent = Math.round(progress) === index;
                                
                                return (
                                    <div key={step.id} className="absolute inset-0 w-full h-full flex items-center justify-center pointer-events-none">
                                        <div className="relative w-full h-full" style={{ opacity: imgOpacity, transform: `scale(${scale})` }}>
                                            <ImageWithFallback src={step.src} fallbackColor={step.color} />
                                        </div>
                                        
                                        {isCurrent && (
                                            <div className="absolute bottom-0 left-0 right-0 p-8 pb-16 bg-gradient-to-t from-black via-black/80 to-transparent text-center">
                                                <div className="max-w-4xl mx-auto space-y-4 animate-pop">
                                                    <h2 className="text-4xl md:text-6xl text-amber-500 font-pirata drop-shadow-lg">{step.title}</h2>
                                                    <p className="text-xl md:text-2xl text-gray-200 font-serif leading-relaxed text-justify">{step.narration}</p>
                                                    {step.id === 'dm-fading' && (
                                                        <div className="pt-6 pointer-events-auto">
                                                            <button onClick={window.transitionIntroToGate} className="btn-enter-gate animate-pulse">Awaken</button>
                                                        </div>
                                                    )}
                                                </div>
                                            </div>
                                        )}
                                    </div>
                                );
                            })}
                            
                            <div className="absolute right-4 top-1/2 -translate-y-1/2 flex flex-col gap-4 pointer-events-auto">
                                {STORY_STEPS.map((_, i) => (
                                    <button key={i} onClick={() => snapToNearest(i)} className={`w-3 h-3 rounded-full border-2 ${Math.round(progress)===i ? 'bg-amber-500 border-amber-500' : 'border-white/50'}`} />
                                ))}
                            </div>
                        </div>
                    )}
                </div>
            );
        }
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<IntroApp />);
    </script>

    <!-- === LOGIC: Part 2 (The Gates) === -->
    <script type="text/babel" data-type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';
        const { useState, useEffect, useRef, useLayoutEffect } = React;

        function DiceWidget({ onRollComplete, onClose }) {
            const containerRef = useRef(null);
            const rollBtnRef = useRef(null);
            const resultDisplayRef = useRef(null);
            const ctx = useRef({ isRolling: false });
            useLayoutEffect(() => {
                if(!containerRef.current) return;
                const width = containerRef.current.clientWidth;
                const height = containerRef.current.clientHeight;
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf1f5f9);
                const camera = new THREE.PerspectiveCamera(35, width/height, 0.1, 100);
                camera.position.set(0, 18, 9);
                camera.lookAt(0, 0, 0);
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(width, height);
                renderer.shadowMap.enabled = true;
                containerRef.current.appendChild(renderer.domElement);
                const world = new CANNON.World();
                world.gravity.set(0, -50, 0);
                const mat = new CANNON.Material();
                world.addContactMaterial(new CANNON.ContactMaterial(mat, mat, { friction: 0.3, restitution: 0.5 }));
                scene.add(new THREE.AmbientLight(0xffffff, 0.7));
                const sun = new THREE.DirectionalLight(0xffffff, 1.2);
                sun.position.set(5, 12, 5);
                sun.castShadow = true;
                scene.add(sun);
                const groundBody = new CANNON.Body({ mass: 0, material: mat });
                groundBody.addShape(new CANNON.Plane());
                groundBody.quaternion.setFromEuler(-Math.PI/2, 0, 0);
                world.addBody(groundBody);
                const addWall = (x, z, ry) => {
                    const b = new CANNON.Body({ mass: 0, material: mat });
                    b.addShape(new CANNON.Box(new CANNON.Vec3(10, 10, 1)));
                    b.position.set(x, 10, z); b.quaternion.setFromEuler(0, ry, 0);
                    world.addBody(b);
                };
                addWall(0, -3.5, 0); addWall(0, 3.5, 0); addWall(-5, 0, Math.PI/2); addWall(5, 0, Math.PI/2);
                const geo = new THREE.IcosahedronGeometry(1.5);
                const dieMesh = new THREE.Group();
                const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ color: 0x3b82f6, flatShading: true }));
                mesh.castShadow = true; dieMesh.add(mesh);
                const pos = geo.attributes.position;
                const vertices = [], faces = [], logicalFaces = [];
                for(let i=0; i<pos.count; i++) vertices.push(new CANNON.Vec3(pos.getX(i), pos.getY(i), pos.getZ(i)));
                for(let i=0; i<pos.count; i+=3) faces.push([i, i+1, i+2]);
                for(let i=0; i<pos.count; i+=3) {
                    const a = new THREE.Vector3().fromBufferAttribute(pos, i);
                    const b = new THREE.Vector3().fromBufferAttribute(pos, i+1);
                    const c = new THREE.Vector3().fromBufferAttribute(pos, i+2);
                    const n = new THREE.Vector3().crossVectors(new THREE.Vector3().subVectors(c,b), new THREE.Vector3().subVectors(a,b)).normalize();
                    if(!logicalFaces.find(lf => lf.normal.dot(n) > 0.99)) {
                        const canvas = document.createElement('canvas'); canvas.width=64; canvas.height=64;
                        const ctx2d = canvas.getContext('2d'); ctx2d.fillStyle='white'; ctx2d.font='bold 40px Arial'; ctx2d.textAlign='center'; ctx2d.textBaseline='middle';
                        ctx2d.fillText(logicalFaces.length+1, 32, 32);
                        const p = new THREE.Mesh(new THREE.PlaneGeometry(0.8,0.8), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(canvas), transparent:true, polygonOffset:true, polygonOffsetFactor:-1 }));
                        const center = new THREE.Vector3().add(a).add(b).add(c).multiplyScalar(1/3);
                        p.position.copy(center).add(n.clone().multiplyScalar(0.01)); p.lookAt(center.clone().add(n));
                        dieMesh.add(p);
                        logicalFaces.push({ normal: n, value: logicalFaces.length + 1 });
                    }
                }
                const body = new CANNON.Body({ mass: 5, shape: new CANNON.ConvexPolyhedron({ vertices, faces }), material: mat });
                body.position.set(0, 4, 0); world.addBody(body); scene.add(dieMesh);
                ctx.current = { scene, world, body, dieMesh, logicalFaces, renderer, isRolling: false };
                let animId;
                const animate = () => {
                    world.step(1/60);
                    dieMesh.position.copy(body.position); dieMesh.quaternion.copy(body.quaternion);
                    renderer.render(scene, camera);
                    animId = requestAnimationFrame(animate);
                };
                animate();
                return () => { 
                    cancelAnimationFrame(animId); 
                    if(renderer.domElement && containerRef.current) containerRef.current.removeChild(renderer.domElement);
                    renderer.dispose(); 
                };
            }, []);
            const roll = () => {
                const c = ctx.current; if(c.isRolling) return;
                c.isRolling = true; rollBtnRef.current.disabled = true;
                resultDisplayRef.current.classList.remove('visible');
                c.body.position.set(0, 6, 0);
                c.body.applyImpulse(new CANNON.Vec3((Math.random()-.5)*15, -10, (Math.random()-.5)*15), new CANNON.Vec3(0,0,0));
                c.body.angularVelocity.set(Math.random()*25, Math.random()*25, Math.random()*25);
                const check = setInterval(() => {
                    if(c.body.velocity.length() < 0.1 && c.body.angularVelocity.length() < 0.1) {
                        clearInterval(check);
                        const q = new THREE.Quaternion().copy(c.body.quaternion);
                        let best = -Infinity, res = 1;
                        c.logicalFaces.forEach(f => {
                            const d = f.normal.clone().applyQuaternion(q).dot(new THREE.Vector3(0,1,0));
                            if(d > best) { best = d; res = f.value; }
                        });
                        resultDisplayRef.current.innerText = res; resultDisplayRef.current.classList.add('visible');
                        c.isRolling = false; rollBtnRef.current.disabled = false;
                        setTimeout(() => onRollComplete(res), 1200);
                    }
                }, 100);
            };
            return (
                <div className="fixed inset-0 z-[600] flex items-center justify-center bg-black/80 backdrop-blur-sm p-4">
                    <div className="dice-widget-container">
                        <div id="widget-ui">
                            <div className="text-center pb-2 border-b border-black/5">
                                <span className="text-[0.7rem] uppercase font-bold tracking-widest text-slate-500">Polyhedral Engine</span>
                                <button onClick={onClose} className="absolute top-3 right-3 text-slate-400">✕</button>
                            </div>
                            <div id="result-display" ref={resultDisplayRef}>20</div>
                            <div className="controls-area">
                                <div className="flex justify-between bg-black/5 p-1 rounded-lg">
                                    {['D4','D6','D8','D10','D12','D20'].map(d => (
                                        <span key={d} className={`text-[0.65rem] font-bold p-1 px-2 rounded ${d==='D20'?'bg-white text-blue-600 shadow-sm':'text-slate-400'}`}>{d}</span>
                                    ))}
                                </div>
                                <button id="roll-btn" ref={rollBtnRef} onClick={roll}>Cast the Die</button>
                            </div>
                        </div>
                        <div ref={containerRef} className="w-full h-full"></div>
                    </div>
                </div>
            );
        }

        function GateApp() {
            const [gameState, setGameState] = useState('intro');
            const [mode, setMode] = useState('normal');
            const [rolls, setRolls] = useState([]);
            const [showDice, setShowDice] = useState(false);

            const narrative = {
                intro: "The iron-bound gates of Haven’s Keep stand before you, locked tight against the blizzard. Your body is failing; this is your final chance to find warmth. The DC is 10.",
                progress: `The first attempt failed (${rolls[0]}). Your vision is darkening, your fingers are numb. One last surge of adrenaline is all you have left.`,
                success: "Victory! With a final result strong enough to move the bars, you heave the gates open. The warmth of the keep spills out, saving you from the storm.",
                fail: "The world turns white. You feel the cold iron against your cheek as you sink into the mud, the storm finally claiming its prize...",
                rescue: "Suddenly... light. The groan of heavy hinges. Warm hands grab your shoulders. 'Easy now, traveler,' a rough voice grunts through the gale. 'The hearth is this way.' You are carried into the warmth as consciousness fades."
            };

            const handleRoll = (res) => {
                const nextRolls = [...rolls, res]; 
                setRolls(nextRolls);
                
                if (res >= 10) {
                    setGameState('success');
                    setShowDice(false);
                } else if (nextRolls.length >= 2) {
                    setGameState('fail');
                    setShowDice(false);
                } else {
                    setGameState('progress');
                    setShowDice(false);
                    setTimeout(() => setShowDice(true), 1500);
                }
            };

            const triggerRescue = () => {
                window.gameStateFlags.wasRescued = true;
                setGameState('rescue');
            };

            return (
                <div className="h-full w-full flex items-center justify-center p-4">
                    <div className="w-full max-w-4xl max-h-[90vh] overflow-y-auto custom-scroll p-4 md:p-8 space-y-8 text-center">
                        <h1 className="text-4xl md:text-7xl font-pirata text-amber-500 tracking-wider uppercase text-shadow-heavy drop-shadow-xl">
                            {gameState === 'success' ? 'Sanctuary Found' : (gameState === 'fail' || gameState === 'rescue') ? 'Fading Out' : 'The Final Threshold'}
                        </h1>
                        <p className="text-xl md:text-2xl text-gray-100 leading-relaxed font-serif min-h-[100px] pb-6 text-shadow-heavy max-w-2xl mx-auto">{narrative[gameState]}</p>

                        {gameState === 'intro' && (
                            <div className="grid grid-cols-1 gap-4 mt-4 max-w-xs mx-auto">
                                <button onClick={() => { setMode('normal'); setRolls([]); setShowDice(true); }} className="relative p-6 rounded-2xl border-2 shadow-xl bg-gradient-to-br from-indigo-900/90 to-indigo-950/90 border-indigo-500/50 text-indigo-400 hover:scale-105 transition-all">
                                    <div className="text-3xl mb-2">●</div>
                                    <h3 className="font-pirata text-2xl tracking-wide">Enter the Keep</h3>
                                    <p className="text-sm font-bold mt-1">Roll for Strength (DC 10)</p>
                                </button>
                            </div>
                        )}

                        {rolls.length > 0 && gameState !== 'rescue' && (
                            <div className="flex justify-center gap-8 py-4 items-center">
                                {rolls.map((r, i) => (
                                    <div key={i} className="relative flex items-center justify-center transition-all duration-500 scale-110 drop-shadow">
                                        <div className={`w-16 h-16 rounded-full border-4 flex items-center justify-center text-3xl font-pirata bg-black/40 ${r>=10?'border-emerald-500 text-emerald-400':'border-red-500 text-red-400'}`}>{r}</div>
                                    </div>
                                ))}
                            </div>
                        )}

                        {gameState === 'fail' && (
                            <button onClick={triggerRescue} className="w-full max-w-xs mx-auto block text-red-400 font-pirata text-2xl uppercase tracking-widest mt-4 border-2 border-red-500/50 bg-black/60 p-3 rounded-xl hover:bg-black/80 shadow-xl">
                                Next...
                            </button>
                        )}

                        {(gameState === 'success' || gameState === 'rescue') && (
                            <button onClick={window.transitionGateToTavern} className="w-full max-w-md mx-auto block text-amber-500 font-pirata text-3xl uppercase tracking-widest mt-4 border-2 border-amber-500/50 bg-black/60 backdrop-blur p-3 rounded-xl hover:bg-black/80 hover:border-amber-400 shadow-xl animate-pulse">
                                {gameState === 'success' ? 'Step Inside' : 'Awaken by the Fire'}
                            </button>
                        )}
                    </div>
                    {showDice && <DiceWidget onRollComplete={handleRoll} onClose={() => setShowDice(false)} />}
                </div>
            );
        }

        const gateRoot = ReactDOM.createRoot(document.getElementById('gate-root'));
        gateRoot.render(<GateApp />);
    </script>

    <!-- === LOGIC: Part 3 (Tavern & Battle System) === -->
    <script>
        const characterStats = { STR: 0, DEX: 0, INT: 0, CHA: 0, GOLD: 5 };
        const questLog = { bartho: 'pending', elara: 'pending', table: 'pending', stranger: 'pending' };
        const questMemories = { bartho: null, elara: null, table: null, stranger: null };
        const gameStateFlags = { hasRoom: false, hasEaten: false, wasRescued: false };

        let activeStat = null;
        let statRolls = []; 
        let isGeneratingStat = false;
        let isSkillCheck = false;
        let activeDC = 10;
        let activeSuccessScene = '';
        let activeFailScene = '';
        let activeQuestKey = '';
        let currentSceneKey = 'hub';

        function updateGoldUI() {
            document.getElementById('gold-val').innerText = characterStats.GOLD;
        }

        function buyRoom() {
            if(characterStats.GOLD >= 2) {
                characterStats.GOLD -= 2;
                gameStateFlags.hasRoom = true;
                updateGoldUI();
                addToStory("Rented a room for the night. (Cost: 2 Gold)");
                loadScene('bartho');
            }
        }

        function buyStew() {
            if(characterStats.GOLD >= 1) {
                characterStats.GOLD -= 1;
                gameStateFlags.hasEaten = true;
                updateGoldUI();
                addToStory("Ate a hearty warm stew. (Cost: 1 Gold)");
                loadScene('elara');
            }
        }

        function finishGame() {
            const ov = document.getElementById('overlay');
            ov.classList.remove('hidden');
            const icon = document.getElementById('overlay-icon');
            if (icon) icon.setAttribute('data-lucide', 'party-popper');
            document.getElementById('overlay-title').innerText = "CONGRATULATIONS!";
            document.getElementById('overlay-sub').innerText = "You have discovered your inner strength, filled your belly, and secured a safe harbor. Your journey through Haven's Keep has truly begun.";
            const btn = document.getElementById('overlay-btn');
            btn.innerText = "REST VICTORIOUS";
            btn.onclick = () => location.reload();
            if (window.lucide) window.lucide.createIcons();
        }

        const RAILWAY_URL = "https://fight-tavern-production.up.railway.app";
        let socket = null;
        let isMultiplayerActive = false; 
        let isServerOffline = false;     

        if (typeof io !== 'undefined') {
            socket = io(RAILWAY_URL);
            socket.on('connect', () => {
                isServerOffline = false;
                refreshHubButton();
            });
            socket.on('connect_error', () => {
                isServerOffline = true;
                isMultiplayerActive = false;
                refreshHubButton();
            });
        } else {
            isServerOffline = true;
        }
        
        const IMAGES = {
            warrior: "https://image.pollinations.ai/prompt/fantasy%20warrior%20portrait%20rugged%20face%20scarred%20armor%20heroic%20lighting%201970s%20dnd%20art%20style%20oil%20painting?width=400&height=400&nologin=true&seed=99",
            ogre: "https://image.pollinations.ai/prompt/fearsome%20ogre%20portrait%20fantasy%20art%201970s%20style?width=400&height=400&nologin=true&seed=505",
        };

        const app = {
            openGame(mode) {
                if (!socket) return;
                battle.init();
                if(mode === 'challenge') {
                    socket.emit('send_challenge');
                } else {
                    socket.emit('join_game', { mode: mode });
                    document.getElementById('lobby-panel').classList.add('hidden');
                    document.getElementById('game-widget').classList.remove('hidden');
                }
            },
            acceptChallenge() {
                if (!socket) return;
                battle.init(); 
                socket.emit('accept_challenge');
                document.getElementById('challenge-modal').classList.add('hidden');
                document.getElementById('lobby-panel').classList.add('hidden');
                document.getElementById('game-widget').classList.remove('hidden');
            },
            closeWidget() {
                document.getElementById('game-widget').classList.add('hidden');
                document.getElementById('lobby-panel').classList.remove('hidden');
            }
        };

        function refreshHubButton() {
            const imgElement = document.getElementById('scene-image');
            if (imgElement && imgElement.src.includes('Tavern.png') && document.getElementById('choice-grid').style.display !== 'none') {
                loadScene('hub'); 
            }
        }

        if (socket) {
            socket.on('lobby_stats', (stats) => {
                const statusText = document.getElementById('lobby-status-text');
                const actionsDiv = document.getElementById('lobby-actions');
                const countText = document.getElementById('lobby-count');
                if (stats.connected > 1) isMultiplayerActive = true;
                else isMultiplayerActive = false;
                if(!countText) return;
                countText.innerText = `${stats.connected} Patrons in the Tavern`;
                let actionHtml = '';
                if (stats.gameInProgress) {
                    socket.emit('check_rejoin');
                    statusText.innerText = "Battle in Progress!";
                    statusText.className = "text-lg text-red-400 font-bold animate-pulse";
                    actionHtml = `<button onclick="app.openGame('spectate')" class="w-full bg-slate-700 hover:bg-slate-600 text-white py-3 rounded-lg font-bold flex items-center justify-center gap-2 border border-slate-600"><i data-lucide="eye" class="w-4 h-4"></i> Watch Battle</button>`;
                } 
                else if (stats.connected > 1) {
                    statusText.innerText = "Opponent Available!";
                    statusText.className = "text-lg text-yellow-400 font-bold";
                    actionHtml = `
                        <button id="challenge-btn" onclick="app.openGame('challenge')" class="w-full bg-yellow-600 hover:bg-yellow-500 text-white py-4 rounded-lg font-bold flex items-center justify-center gap-2 border border-yellow-400 shadow-lg shadow-yellow-900/20"><i data-lucide="swords" class="w-5 h-5"></i> SEND CHALLENGE</button>
                        <div class="text-center text-xs text-slate-500 mt-2">or</div>
                        <button onclick="app.openGame('pve')" class="w-full bg-slate-800 hover:bg-slate-700 text-slate-400 py-2 rounded-lg font-bold text-sm flex items-center justify-center gap-2 border border-slate-700 mt-2"><i data-lucide="bot" class="w-4 h-4"></i> Practice vs CPU</button>
                    `;
                } 
                else {
                    statusText.innerText = "You are Alone...";
                    statusText.className = "text-lg text-slate-400 font-bold";
                    actionHtml = `
                        <button onclick="app.openGame('pve')" class="w-full bg-blue-900 hover:bg-blue-800 text-blue-100 py-4 rounded-lg font-bold flex items-center justify-center gap-2 border border-blue-700 shadow-lg shadow-blue-900/20"><i data-lucide="bot" class="w-5 h-5"></i> PLAY VS COMPUTER</button>
                        <div class="text-xs text-slate-500 mt-2">Waiting for another human...</div>
                    `;
                }
                actionsDiv.innerHTML = actionHtml;
                if (window.lucide) window.lucide.createIcons();
            });
            socket.on('challenge_received', () => {
                const modal = document.getElementById('challenge-modal');
                if(modal) { modal.classList.remove('hidden'); modal.classList.add('flex'); }
            });
            socket.on('challenge_canceled', () => {
                const modal = document.getElementById('challenge-modal');
                if(modal) { modal.classList.add('hidden'); modal.classList.remove('flex'); }
            });
        }

        const battle = {
            myRole: null, isMyTurn: false,
            init() {
                document.getElementById('hero-img').src = IMAGES.warrior;
                document.getElementById('enemy-img').src = IMAGES.ogre;
                if (window.lucide) window.lucide.createIcons();
                this.setupSocket();
                if (socket) socket.emit('check_rejoin');
            },
            setupSocket() {
                if (!socket) return;
                socket.off('welcome'); socket.off('game_update'); socket.off('chat_message'); socket.off('player_left');
                socket.on('welcome', (data) => {
                    this.myRole = data.role;
                    if (this.myRole === 'hero' || this.myRole === 'enemy') {
                        document.getElementById('lobby-panel').classList.add('hidden');
                        document.getElementById('game-widget').classList.remove('hidden');
                        document.getElementById('challenge-modal').classList.add('hidden');
                        document.getElementById('challenge-modal').classList.remove('flex');
                    }
                    const alert = document.getElementById('role-alert');
                    if(this.myRole === 'hero') alert.innerText = "You: Warrior";
                    else if(this.myRole === 'enemy') alert.innerText = "You: Ogre";
                    else alert.innerText = "Spectating";
                    this.updateUI(data.state);
                });
                socket.on('game_update', (data) => {
                    this.updateUI(data.state);
                    if(data.action) this.handleAction(data.action);
                });
                socket.on('player_left', (data) => {
                    const ov = document.getElementById('overlay');
                    ov.classList.remove('hidden');
                    document.getElementById('overlay-title').innerText = "OPPONENT LEFT";
                    document.getElementById('overlay-sub').innerText = "The battle is cancelled.";
                    const btn = document.getElementById('overlay-btn');
                    btn.innerText = "BACK TO LOBBY";
                    btn.onclick = () => { ov.classList.add('hidden'); app.closeWidget(); };
                });
                socket.on('chat_message', (data) => {
                    const box = document.getElementById('chat-messages');
                    const color = data.role === 'hero' ? 'text-blue-400' : (data.role === 'enemy' ? 'text-red-400' : 'text-slate-500');
                    const name = data.role === 'hero' ? 'WAR' : (data.role === 'enemy' ? 'OGR' : (data.role === 'bot' ? 'CPU' : 'SPEC'));
                    const el = document.createElement('div');
                    el.innerHTML = `<span class="font-bold ${color} text-[10px] mr-1 uppercase tracking-wide">${name}</span><span class="text-slate-300 text-xs">${data.text}</span>`;
                    box.appendChild(el);
                    box.scrollTop = box.scrollHeight;
                });
            },
            sendAttack() {
                if(!this.isMyTurn || !socket) return;
                document.getElementById('d20-btn').classList.add('rolling');
                socket.emit('attack');
            },
            sendChat(e) {
                e.preventDefault();
                if (!socket) return;
                const input = document.getElementById('chat-input');
                if(input.value.trim()) { socket.emit('send_chat', input.value.trim()); input.value = ''; }
            },
            resetGame() { if(socket) socket.emit('reset_game'); },
            updateUI(state) {
                const setStats = (id, cur, max) => {
                    document.getElementById(id + '-hp-text').innerText = `${cur}/${max}`;
                    const pct = (cur/max)*100;
                    document.getElementById(id + '-bar').style.width = `${pct}%`;
                    setTimeout(() => document.getElementById(id + '-chip').style.width = `${pct}%`, 500);
                };
                setStats('hero', state.hero.hp, state.hero.max);
                setStats('enemy', state.enemy.hp, state.enemy.max);
                if(state.gameOver) {
                    const ov = document.getElementById('overlay');
                    ov.classList.remove('hidden');
                    document.getElementById('overlay-title').innerText = state.hero.hp > 0 ? "VICTORY" : "DEFEAT";
                    document.getElementById('overlay-sub').innerText = state.hero.hp > 0 ? "The Warrior prevails!" : "The Ogre feasts!";
                    const btn = document.getElementById('overlay-btn');
                    btn.innerText = "PLAY AGAIN";
                    btn.onclick = () => battle.resetGame();
                    return;
                } else if (document.getElementById('overlay-title').innerText !== "OPPONENT LEFT") {
                    document.getElementById('overlay').classList.add('hidden');
                }
                this.isMyTurn = (this.myRole === state.turn);
                const btn = document.getElementById('d20-btn');
                const dieBg = document.getElementById('die-bg');
                const dieText = document.getElementById('die-text');
                btn.classList.remove('rolling');
                const heroCard = document.getElementById('hero-card');
                const enemyCard = document.getElementById('enemy-card');
                if(state.turn === 'hero') {
                    heroCard.classList.add('active-turn'); heroCard.classList.remove('inactive-turn');
                    enemyCard.classList.remove('active-turn'); enemyCard.classList.add('inactive-turn');
                } else {
                    enemyCard.classList.add('active-turn'); enemyCard.classList.remove('inactive-turn');
                    heroCard.classList.remove('active-turn'); heroCard.classList.add('inactive-turn');
                }
                if(this.isMyTurn) {
                    btn.classList.remove('die-disabled');
                    dieBg.classList.replace('fill-slate-800', 'fill-red-900');
                    dieBg.classList.replace('stroke-slate-600', 'stroke-red-500');
                    dieText.classList.replace('fill-slate-500', 'fill-white');
                    document.getElementById('action-log').innerText = "YOUR TURN";
                    document.getElementById('action-log').className = "text-sm font-bold text-yellow-400 animate-pulse";
                } else {
                    btn.classList.add('die-disabled');
                    dieBg.classList.replace('fill-red-900', 'fill-slate-800');
                    dieBg.classList.replace('stroke-red-500', 'stroke-slate-600');
                    dieText.classList.replace('fill-white', 'fill-slate-500');
                    const who = state.turn === 'hero' ? "Warrior" : "Ogre";
                    document.getElementById('action-log').innerText = `${who} attacking...`;
                    document.getElementById('action-log').className = "text-sm font-bold text-slate-500";
                }
            },
            handleAction(action) {
                document.getElementById('action-log').innerText = action.log.msg;
                document.getElementById('action-log').className = `text-sm font-bold ${action.log.color}`;
                document.getElementById('math-log').innerText = action.log.sub || "";
                const targetId = action.attacker === 'hero' ? 'enemy-card' : 'hero-card';
                const card = document.getElementById(targetId);
                if(action.isHit) {
                    const img = card.querySelector('img');
                    img.style.filter = "sepia(1) hue-rotate(-50deg) saturate(5)";
                    setTimeout(() => img.style.filter = "", 200);
                    card.classList.add('animate-shake');
                    setTimeout(() => card.classList.remove('animate-shake'), 500);
                }
            }
        };

        function toggleFightModal() {
            const modal = document.getElementById('fight-modal');
            if(modal.classList.contains('active')) { modal.classList.remove('active'); }
            else { modal.classList.add('active'); if (window.lucide) window.lucide.createIcons(); }
        }

        async function triggerAIChat(npcKey) {
            const npcMap = { 'bartho': 'Bartho the Innkeeper', 'elara': 'Elara the Barmaid', 'table': 'A wizard and a warrior', 'stranger': 'A mysterious cloaked stranger' };
            const name = npcMap[npcKey];
            const dialogueText = document.getElementById('dialogue-text');
            dialogueText.innerHTML = `<span style="color:#aaa; font-style:italic;">${name} is thinking...</span>`;
            const prompt = `Roleplay as ${name} in a fantasy tavern. Respond to the player in character. Keep it under 2 sentences. Seed: ${Math.random()}`; 
            try {
                const response = await fetch(`https://text.pollinations.ai/${encodeURIComponent(prompt)}`);
                if (response.ok) { const text = await response.text(); dialogueText.innerText = `"${text}"`; }
                else { dialogueText.innerText = "The spirits are silent."; }
            } catch (e) { dialogueText.innerText = "The spirits are silent."; }
        }

        function generateMemory(npc, isSuccess) {
            const style = "dark fantasy visual novel art style, digital painting, atmospheric, cinematic lighting, detailed, masterpiece";
            let desc = "";
            if (npc === 'bartho') desc = isSuccess ? `strong warrior lifting keg in tavern, ${style}` : `shattered keg in tavern, ${style}`;
            else if (npc === 'elara') desc = isSuccess ? `catching falling mugs heroically, ${style}` : `broken mugs on floor, ${style}`;
            else if (npc === 'table') desc = isSuccess ? `wizard and warrior shaking hands in tavern, ${style}` : `wizard and warrior arguing in tavern, ${style}`;
            else if (npc === 'stranger') desc = isSuccess ? `winning chess move, ${style}` : `chess defeat, ${style}`;
            if (desc) {
                const seed = Math.floor(Math.random() * 10000);
                const url = `https://image.pollinations.ai/prompt/${encodeURIComponent(desc)}?width=1024&height=1024&seed=${seed}&nologo=true`;
                questMemories[npc] = url;
                new Image().src = url;
            }
        }

        function showMemory(npc) {
            const url = questMemories[npc];
            if (!url) return;
            document.getElementById('memory-img').src = url;
            document.getElementById('memory-modal').classList.add('active');
        }
        function closeMemory() { document.getElementById('memory-modal').classList.remove('active'); }

        const scenes = {
            'exterior': { 
                title: "The Flickering Sign", image: "TavernNight.png", 
                dialogue: () => {
                    if (gameStateFlags.wasRescued) {
                        return "The last thing you remember was the bite of the frost and the sound of iron meeting stone. Now, you stand before the 'Weary Traveler'. A mysterious stranger has dragged you from death's door to this threshold. The golden light from the windows promises life.";
                    }
                    return "The storm howls behind you like a wounded beast, but the warm glow of the tavern offers a promise of safety and civilization.";
                },
                choices: [ { text: "Enter the Tavern", action: "loadScene('hub')" } ] 
            },
            'hub': { 
                title: "The Weary Traveler", image: "Tavern.png", isHub: true, 
                choices: [ 
                    { text: "Talk to Bartho", action: "loadScene('bartho')" }, 
                    { text: "Speak with Elara", action: "loadScene('elara')" }, 
                    { text: "Approach the Wizard & Warrior", action: "loadScene('table')" }, 
                    { text: "Observe the Stranger", action: "loadScene('stranger')" }, 
                    { text: "Go to Your Quarters", action: "loadScene('room')" },
                    { 
                        text: () => {
                            if (isServerOffline) return "Battle Arena (Offline)";
                            if (isMultiplayerActive) return "LIVE BATTLE (Join)";
                            return "Enter Battle Arena";
                        }, 
                        action: "toggleFightModal()", 
                        class: () => {
                            if (isServerOffline) return "btn-choice offline-btn";
                            if (isMultiplayerActive) return "btn-choice live-battle";
                            return "btn-choice battle-btn";
                        }
                    }
                ] 
            },
            'bartho': { 
                title: "The Innkeeper", image: "Bartender.png", isHub: false, 
                dialogue: () => {
                    if (gameStateFlags.hasRoom) return "Bartho pauses his cleaning to nod at you. 'Safe travels upstairs, friend. Your room is the third on the left. Don't mind the creaky floorboards.'";
                    if (questLog.bartho === 'success') return "The big man grunts in approval. 'I haven't seen a keg moved that quickly since the last time a giant came through. You've got the spirit of a bear, traveler.'";
                    if (questLog.bartho === 'fail') return "Bartho sighs as he looks at the mess. 'Well, at least you didn't break the floor. Maybe leave the heavy lifting to the professionals for now.'";
                    return "The burly innkeeper wipes down a glass with a rag that has seen better centuries. He eyes your worn boots. 'New to Blackwood? Move this heavy oak keg behind the counter for me, and I'll see about finding you a discounted room.'";
                },
                choices: [ 
                    { text: "Rent Room (2 Gold)", condition: ()=> !gameStateFlags.hasRoom && characterStats.GOLD >= 2, action: "buyRoom()", class: "gold-btn" },
                    { text: "I'll move it (Roll STR)", condition: ()=>questLog.bartho==='pending'&&characterStats.STR===0, action: "startStatTest('STR','bartho_post_stat')" }, 
                    { text: "Lift the Keg", condition: ()=>questLog.bartho==='pending'&&characterStats.STR>0, action: "loadScene('bartho_post_stat')" }, 
                    { text: "Recall Memory", condition: () => questMemories.bartho, action: "showMemory('bartho')", class: "mem-btn" },
                    { text: "Chat (AI)", action: "triggerAIChat('bartho')", class: "ai-btn" },
                    { text: "Leave", action: "loadScene('hub')" } 
                ] 
            },
            'bartho_post_stat': { title: "The Challenge", image: "Bartender.png", dialogue: "The keg is bound in iron and smells of old, fermented grain. It feels like it's filled with lead rather than ale.", choices: [ { text: "Heave with all your might! (DC 12)", action: "startSkillCheck('STR', 12, 'bartho_win', 'bartho_lose', 'bartho')" } ] },
            'bartho_win': { title: "Success!", image: "Bartender.png", dialogue: "With a guttural roar, you hoist the keg and slide it effortlessly behind the counter. Bartho looks impressed, even if he doesn't say it.", choices: [ { text: "Accept his thanks", action: "loadScene('hub')" } ] },
            'bartho_lose': { title: "Failure...", image: "Bartender.png", dialogue: "The keg doesn't budge an inch. Your hands slip on the condensation, and you nearly tumble over. Bartho just shakes his head slowly.", choices: [ { text: "Walk away in shame", action: "loadScene('hub')" } ] },
            'elara': { 
                title: "The Hearth", image: "Barmaid.png", isHub: false, 
                dialogue: () => {
                    if (gameStateFlags.hasEaten) return "Elara smiles warmly, her face lit by the hearth fire. 'That stew usually does the trick. You look like you've finally stopped shivering.'";
                    if (questLog.elara === 'success') return "Elara beams. 'I've never seen someone move that fast! You saved me a whole night of cleaning and a dozen broken mugs. You're a hero in my book.'";
                    if (questLog.elara === 'fail') return "Elara is busy sweeping up shards of glass. 'It's alright, really... the floor was due for a scrubbing anyway. Just... watch your step next time.'";
                    return "Elara navigates the crowded room with practiced ease until a rowdy patron bumps her shoulder. Her tray of full mugs tilts dangerously over the stone floor!";
                },
                choices: [ 
                    { text: "Buy Hearty Stew (1 Gold)", condition: ()=> !gameStateFlags.hasEaten && characterStats.GOLD >= 1, action: "buyStew()", class: "gold-btn" },
                    { text: "Catch the Tray! (Roll DEX)", condition: ()=>questLog.elara==='pending'&&characterStats.DEX===0, action: "startStatTest('DEX','elara_post_stat')" }, 
                    { text: "Attempt the Catch", condition: ()=>questLog.elara==='pending'&&characterStats.DEX>0, action: "loadScene('elara_post_stat')" }, 
                    { text: "Recall Memory", condition: () => questMemories.elara, action: "showMemory('elara')", class: "mem-btn" },
                    { text: "Chat (AI)", action: "triggerAIChat('elara')", class: "ai-btn" },
                    { text: "Leave", action: "loadScene('hub')" } 
                ] 
            },
            'elara_post_stat': { title: "Reflex Test", image: "Barmaid.png", dialogue: "Time seems to slow as the mugs slide off the polished wood. You need to react now!", choices: [ { text: "Snatch them mid-air! (DC 13)", action: "startSkillCheck('DEX', 13, 'elara_win', 'elara_lose', 'elara')" } ] },
            'elara_win': { title: "Incredible!", image: "Barmaid.png", dialogue: "Your hand flashes out, steadying the tray just inches from the ground. Not a single drop is spilled. The nearby patrons let out a low whistle of approval.", choices: [ { text: "Return the tray", action: "loadScene('hub')" } ] },
            'elara_lose': { title: "Crash!", image: "Barmaid.png", dialogue: "Your fingers brush against a mug, but you can't get a grip. The tray hits the stones with a deafening clatter and the smell of spilled ale fills the air.", choices: [ { text: "Apologize and retreat", action: "loadScene('hub')" } ] },
            'table': { 
                title: "The Common Room", image: "Table.png", 
                dialogue: () => {
                    if (questLog.table === 'success') return "The warrior raises his glass to you, and the wizard offers a knowing smile. 'A fine tale, traveler. Perhaps you'll join us for a proper adventure soon.'";
                    if (questLog.table === 'fail') return "The warrior looks back to his maps, and the wizard returns to his scrolls. Your attempt to impress them fell flat.";
                    return "A wizard in shimmering robes and a scarred warrior in heavy plate sit huddled over a map. They speak in hushed tones, but they seem to be looking for someone with a silver tongue to help them negotiate with the city guard.";
                },
                choices: [ 
                    { text: "Introduce Yourself (Roll CHA)", condition: ()=>questLog.table==='pending'&&characterStats.CHA===0, action: "startStatTest('CHA','table_post_stat')" }, 
                    { text: "Join their Conversation", condition: ()=>questLog.table==='pending'&&characterStats.CHA>0, action: "loadScene('table_post_stat')" }, 
                    { text: "Recall Memory", condition: () => questMemories.table, action: "showMemory('table')", class: "mem-btn" },
                    { text: "Chat (AI)", action: "triggerAIChat('table')", class: "ai-btn" },
                    { text: "Leave", action: "loadScene('hub')" } 
                ] 
            },
            'table_post_stat': { title: "Diplomacy", image: "Table.png", dialogue: "You pull up a stool and attempt to charm the unlikely pair with stories of your travels.", choices: [ { text: "Tell a compelling tale! (DC 12)", action: "startSkillCheck('CHA', 12, 'table_win', 'table_lose', 'table')" } ] },
            'table_win': { title: "A Captivated Audience", image: "Table.png", dialogue: "The warrior laughs heartily at your wit, and the wizard leans in, fascinated by your descriptions. You've earned their respect and a potential invitation.", choices: [ { text: "Bow gracefully", action: "loadScene('hub')" } ] },
            'table_lose': { title: "Awkward Silence", image: "Table.png", dialogue: "Your story meanders and the punchline lands with a thud. The warrior stares at you blankly while the wizard sighs and adjusts his spectacles.", choices: [ { text: "Excuse yourself", action: "loadScene('hub')" } ] },
            'stranger': { 
                title: "The Stranger", image: "Stranger.png", 
                dialogue: () => {
                    if (questLog.stranger === 'success') return "The Stranger gives a sharp, single nod. 'A mind like yours is rare in these parts. Keep it sharp; Blackwood has many puzzles.'";
                    if (questLog.stranger === 'fail') return "The figure remains silent, his hand poised over a knight. He has already forgotten you.";
                    return "A cloaked figure sits in the darkest corner, illuminated only by a single candle. He stares at a chessboard with an intensity that suggests more than just a game is at stake. 'Sit,' he whispers. 'Prove your worth.'";
                },
                choices: [ 
                    { text: "Accept the Game (Roll INT)", condition: ()=>questLog.stranger==='pending'&&characterStats.INT===0, action: "startStatTest('INT','stranger_post_stat')" }, 
                    { text: "Make a Move", condition: ()=>questLog.stranger==='pending'&&characterStats.INT>0, action: "loadScene('stranger_post_stat')" }, 
                    { text: "Recall Memory", condition: () => questMemories.stranger, action: "showMemory('stranger')", class: "mem-btn" },
                    { text: "Chat (AI)", action: "triggerAIChat('stranger')", class: "ai-btn" },
                    { text: "Leave", action: "loadScene('hub')" } 
                ] 
            },
            'stranger_post_stat': { title: "Intellectual Battle", image: "Stranger.png", dialogue: "The board is a complex web of traps and sacrifices. You must see three moves ahead.", choices: [ { text: "Calculate the Gambit (DC 13)", action: "startSkillCheck('INT', 13, 'stranger_win', 'stranger_lose', 'stranger')" } ] },
            'stranger_win': { title: "Checkmate", image: "Stranger.png", dialogue: "With a precise move, you corner the stranger's king. He exhales a slow breath and pushes a small velvet pouch toward you. 'Well played.'", choices: [ { text: "Take your reward", action: "loadScene('hub')" } ] },
            'stranger_lose': { title: "Outsmarted", image: "Stranger.png", dialogue: "You realize too late that your defense was a mirage. The stranger's queen sweeps across the board, ending the game in a matter of seconds.", choices: [ { text: "Study the loss", action: "loadScene('hub')" } ] },
            'room': { 
                title: "Quarters", image: "Room.png", 
                dialogue: () => {
                    const statsComplete = characterStats.STR > 0 && characterStats.DEX > 0 && characterStats.INT > 0 && characterStats.CHA > 0;
                    if (!gameStateFlags.hasRoom) return "The heavy oak door is locked tight. You need to rent a room from Bartho before you can rest your weary head.";
                    if (!gameStateFlags.hasEaten) return "The bed looks soft, but your stomach twists with a hollow hunger. You shouldn't try to sleep on an empty stomach.";
                    if (!statsComplete) return "You lie down, but your mind is a storm of fragments. You still don't truly know who you are in this world. You must find your bearings and 'discover' your full self (roll all four stats) before you can find peace.";
                    return "The fire in the hearth is warm, the bed is soft, and your belly is full. More importantly, you have found your strength and discovered your worth among the patrons of the keep. You have survived the storm.";
                },
                choices: [ 
                    { text: "Sleep & Complete Your Chronicle", condition: () => gameStateFlags.hasRoom && gameStateFlags.hasEaten && (characterStats.STR > 0 && characterStats.DEX > 0 && characterStats.INT > 0 && characterStats.CHA > 0), action: "finishGame()", class: "sleep-btn" },
                    { text: "Return to the Tavern", action: "loadScene('hub')" } 
                ] 
            }
        };

        const imgElement = document.getElementById('scene-image');
        const titleElement = document.getElementById('scene-title');
        const choiceGrid = document.getElementById('choice-grid');
        const backBtn = document.getElementById('controls-left');
        const diceModal = document.getElementById('dice-modal-overlay');
        const dialogueArea = document.getElementById('dialogue-area');
        const dialogueText = document.getElementById('dialogue-text');
        const journalModal = document.getElementById('journal-modal');
        const storyLog = document.getElementById('story-log');
        const uiStats = { STR: document.getElementById('str-val'), DEX: document.getElementById('dex-val'), INT: document.getElementById('int-val'), CHA: document.getElementById('cha-val') };

        function loadScene(sceneKey, skipHistory = false) {
            if (!skipHistory && currentSceneKey !== sceneKey) {
                sceneHistory.push(currentSceneKey);
            }
            
            currentSceneKey = sceneKey; 
            const data = scenes[sceneKey];
            imgElement.classList.remove('visible');
            backBtn.classList.remove('active');
            choiceGrid.style.opacity = '0'; choiceGrid.style.pointerEvents = 'none';
            dialogueArea.style.display = 'none';
            
            setTimeout(() => {
                imgElement.src = data.image;
                titleElement.innerText = data.title;
                choiceGrid.innerHTML = '';
                if(data.choices) {
                    data.choices.forEach(c => {
                        if (c.condition && !c.condition()) return;
                        const b = document.createElement('button');
                        b.className = 'btn-choice';
                        let cssClass = typeof c.class === 'function' ? c.class() : (c.class || '');
                        if (cssClass) b.className += ' ' + cssClass;
                        b.innerText = typeof c.text === 'function' ? c.text() : c.text;
                        b.setAttribute('onclick', c.action);
                        choiceGrid.appendChild(b);
                    });
                }
                const onReady = () => {
                    imgElement.classList.add('visible');
                    setTimeout(() => {
                        titleElement.style.opacity = '1';
                        if(data.dialogue) { dialogueText.innerText = typeof data.dialogue === 'function' ? data.dialogue() : data.dialogue; dialogueArea.style.display = 'block'; }
                        choiceGrid.style.display = 'flex';
                        setTimeout(() => { choiceGrid.style.opacity = '1'; choiceGrid.style.pointerEvents = 'auto'; }, 50);
                        
                        if (sceneHistory.length > 0) backBtn.classList.add('active');
                        else backBtn.classList.remove('active');
                    }, 300);
                };
                if (imgElement.complete) onReady(); else { imgElement.onload = onReady; imgElement.onerror = onReady; }
            }, 800);
        }

        function goBack() {
            if (sceneHistory.length > 0) {
                const prev = sceneHistory.pop();
                loadScene(prev, true); 
            }
        }

        function toggleDiceModal() { if (diceModal.classList.contains('active')) { diceModal.classList.remove('active'); restoreDiceUI(); } else diceModal.classList.add('active'); }
        function toggleJournal() { journalModal.classList.toggle('active'); }
        function addToStory(text) { const div = document.createElement('div'); div.className = 'journal-entry'; div.innerText = text; storyLog.appendChild(div); }
        function restrictDiceUI(allowed) { document.querySelectorAll('.die-btn').forEach(b => { if(parseInt(b.dataset.sides) === allowed) { b.classList.remove('display-none'); b.click(); } else { b.classList.add('display-none'); } }); }
        function restoreDiceUI() { document.querySelectorAll('.die-btn').forEach(b => b.classList.remove('display-none')); }
        function startStatTest(stat, next) { if(characterStats[stat]>0) return; activeStat=stat; pendingNextScene=next; isGeneratingStat=true; statRolls=[]; toggleDiceModal(); restrictDiceUI(6); document.querySelector('.dice-title').innerText = `Generating ${stat} (1/3)`; }
        function startSkillCheck(stat, dc, win, lose, key) { isSkillCheck=true; activeStat=stat; activeDC=dc; activeSuccessScene=win; activeFailScene=lose; activeQuestKey=key; toggleDiceModal(); restrictDiceUI(20); const mod = Math.floor((characterStats[stat]-10)/2); document.querySelector('.dice-title').innerText = `Check: ${stat} ${mod>=0?'+':''}${mod} (DC ${dc})`; }

        window.handleDiceResult = function(result) {
            if(isGeneratingStat && activeStat) {
                statRolls.push(result);
                if(statRolls.length < 3) { setTimeout(() => document.querySelector('.dice-title').innerText = `Generating ${activeStat} (${statRolls.length+1}/3)`, 1000); }
                else {
                    const total = statRolls.reduce((a,b)=>a+b,0);
                    characterStats[activeStat] = total;
                    const mod = Math.floor((total-10)/2);
                    uiStats[activeStat].innerHTML = `${total} <span class="stat-mod">(${mod>=0?'+':''}${mod})</span>`;
                    document.querySelector('.dice-title').innerText = `${activeStat} Set to ${total}`;
                    isGeneratingStat = false;
                    addToStory(`Your ${activeStat} is ${total}.`);
                    setTimeout(() => { toggleDiceModal(); restoreDiceUI(); activeStat=null; loadScene(pendingNextScene); }, 1500);
                }
            } else if(isSkillCheck && activeStat) {
                const mod = Math.floor((characterStats[activeStat]-10)/2);
                const total = result+mod;
                const success = total>=activeDC;
                document.querySelector('.dice-title').innerText = `${success?"Success!":"Failure..."} (${result}${mod>=0?'+':''}${mod}=${total} vs DC ${activeDC})`;
                if(activeQuestKey) { questLog[activeQuestKey] = success?'success':'fail'; generateMemory(activeQuestKey, success); }
                setTimeout(() => { toggleDiceModal(); restoreDiceUI(); isSkillCheck=false; activeStat=null; loadScene(success ? activeSuccessScene : activeFailScene); addToStory(success ? `Success on ${activeQuestKey} quest.` : `Failed ${activeQuestKey} quest.`); }, 2500);
            }
        };

        document.addEventListener('DOMContentLoaded', () => {
             addToStory("You arrived at The Weary Traveler after surviving the storm.");
        });
    </script>
    
    <!-- === THREE.JS DICE ENGINE === -->
    <script type="module">
        import * as THREE from 'three';
        import * as CANNON from 'cannon-es';

        const CONFIG = {
            colors: { die: 0x3b82f6, floor: 0xf1f5f9, text: '#ffffff', gold: '#eab308', red: '#dc2626', dark: '#334155' },
            physics: { gravity: -50, friction: 0.3, restitution: 0.5 },
            radius: 1.5
        };

        const STATE = {
            scene: null, camera: null, renderer: null, world: null,
            dieBody: null, dieMesh: null,
            logicalFaces: [], isRolling: false, currentSides: 20
        };

        function init() {
            setupGraphics(); setupPhysics(); setupCage(); spawnDie(20); setupInteractions(); animate();
        }

        function setupGraphics() {
            const container = document.getElementById('canvas-container');
            STATE.scene = new THREE.Scene();
            STATE.scene.background = new THREE.Color(CONFIG.colors.floor);
            STATE.camera = new THREE.PerspectiveCamera(30, 360/500, 0.1, 100);
            STATE.camera.position.set(0, 20, 10);
            STATE.camera.lookAt(0, 0, 0);
            STATE.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            STATE.renderer.setSize(360, 500);
            STATE.renderer.shadowMap.enabled = true;
            STATE.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(STATE.renderer.domElement);
            STATE.scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const sun = new THREE.DirectionalLight(0xffffff, 1.5);
            sun.position.set(5, 15, 5); sun.castShadow = true;
            sun.shadow.mapSize.width = 1024; sun.shadow.mapSize.height = 1024;
            STATE.scene.add(sun);
        }

        function setupPhysics() {
            STATE.world = new CANNON.World();
            STATE.world.gravity.set(0, CONFIG.physics.gravity, 0);
            const mat = new CANNON.Material();
            STATE.world.addContactMaterial(new CANNON.ContactMaterial(mat, mat, CONFIG.physics));
            STATE.sharedMaterial = mat; 
        }

        function setupCage() {
            const floorMesh = new THREE.Mesh(new THREE.PlaneGeometry(20, 20), new THREE.ShadowMaterial({ opacity: 0.2 }));
            floorMesh.rotation.x = -Math.PI / 2; floorMesh.receiveShadow = true;
            STATE.scene.add(floorMesh);
            const addPlane = (pos, rot) => {
                const body = new CANNON.Body({ mass: 0, material: STATE.sharedMaterial });
                body.addShape(new CANNON.Plane()); body.position.copy(pos);
                body.quaternion.setFromEuler(rot.x, rot.y, rot.z);
                STATE.world.addBody(body);
            };
            addPlane(new CANNON.Vec3(0,0,0), new CANNON.Vec3(-Math.PI/2, 0, 0));
            const addWall = (x, z, ry) => {
                const body = new CANNON.Body({ mass: 0, material: STATE.sharedMaterial });
                body.addShape(new CANNON.Box(new CANNON.Vec3(10, 10, 1)));
                body.position.set(x, 10, z); body.quaternion.setFromEuler(0, ry, 0);
                STATE.world.addBody(body);
            };
            addWall(0, -3.5, 0); addWall(0, 3.5, 0); addWall(-5, 0, Math.PI/2); addWall(5, 0, Math.PI/2);
        }

        function getGeometry(sides, r) {
            switch(sides) {
                case 4: return new THREE.TetrahedronGeometry(r);
                case 6: return new THREE.BoxGeometry(r*1.5, r*1.5, r*1.5);
                case 8: return new THREE.OctahedronGeometry(r);
                case 10: return createD10Geometry(r);
                case 12: return new THREE.DodecahedronGeometry(r);
                case 20: return new THREE.IcosahedronGeometry(r);
                default: return new THREE.IcosahedronGeometry(r);
            }
        }

        function createD10Geometry(radius) {
            const vertices = [], indices = [];
            const H = radius * 1.2, R = radius * 1.0, h = radius * 0.2;
            vertices.push(0, H, 0, 0, -H, 0);
            for(let i=0; i<5; i++) {
                const ang = (i * 72) * Math.PI/180;
                vertices.push(Math.cos(ang)*R, h, Math.sin(ang)*R);
            }
            for(let i=0; i<5; i++) {
                const ang = ((i * 72) + 36) * Math.PI/180;
                vertices.push(Math.cos(ang)*R, -h, Math.sin(ang)*R);
            }
            for(let i=0; i<5; i++) {
                const A=2+i, B=7+i, An=2+((i+1)%5), Bn=7+((i+1)%5);
                indices.push(0, B, A,  0, An, B,  1, B, An,  1, An, Bn);
            }
            const geo = new THREE.BufferGeometry();
            geo.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geo.setIndex(indices); geo.computeVertexNormals();
            return geo;
        }

        function spawnDie(sides) {
            if(STATE.dieBody) STATE.world.removeBody(STATE.dieBody);
            if(STATE.dieMesh) STATE.scene.remove(STATE.dieMesh);
            STATE.logicalFaces = []; STATE.currentSides = sides;
            const geometry = getGeometry(sides, CONFIG.radius);
            const material = new THREE.MeshStandardMaterial({ color: CONFIG.colors.die, roughness: 0.1, metalness: 0.2, flatShading: true });
            STATE.dieMesh = new THREE.Group();
            const mesh = new THREE.Mesh(geometry, material); mesh.castShadow = true;
            STATE.dieMesh.add(mesh);
            const { shape, faces } = processGeometry(geometry, sides);
            STATE.logicalFaces = faces;
            STATE.dieBody = new CANNON.Body({ mass: 5, shape, material: STATE.sharedMaterial });
            STATE.dieBody.position.set(0, 4, 0); STATE.dieBody.quaternion.setFromEuler(Math.random()*6, Math.random()*6, 0);
            STATE.world.addBody(STATE.dieBody); STATE.scene.add(STATE.dieMesh);
            addDecals(STATE.dieMesh, STATE.logicalFaces);
        }

        function processGeometry(geometry, sides) {
            if(sides === 6) {
                const s = CONFIG.radius * 1.5 / 2;
                return {
                    shape: new CANNON.Box(new CANNON.Vec3(s, s, s)),
                    faces: [
                        { normal: new THREE.Vector3(1,0,0), center: new THREE.Vector3(s,0,0) },
                        { normal: new THREE.Vector3(-1,0,0), center: new THREE.Vector3(-s,0,0) },
                        { normal: new THREE.Vector3(0,1,0), center: new THREE.Vector3(0,s,0) },
                        { normal: new THREE.Vector3(0,-1,0), center: new THREE.Vector3(0,-s,0) },
                        { normal: new THREE.Vector3(0,0,1), center: new THREE.Vector3(0,0,s) },
                        { normal: new THREE.Vector3(0,0,-1), center: new THREE.Vector3(0,0,-s) }
                    ]
                };
            }
            const pos = geometry.attributes.position;
            const vertices = [], pointsMap = {}, tempFaces = [];
            for(let i=0; i<pos.count; i++) {
                const v = new THREE.Vector3().fromBufferAttribute(pos, i);
                const key = `${v.x.toFixed(3)},${v.y.toFixed(3)},${v.z.toFixed(3)}`;
                if(pointsMap[key] === undefined) { pointsMap[key] = vertices.length; vertices.push(new CANNON.Vec3(v.x, v.y, v.z)); }
            }
            const idx = geometry.index ? geometry.index.array : [...Array(pos.count).keys()];
            for(let i=0; i<idx.length; i+=3) { tempFaces.push([idx[i], idx[i+1], idx[i+2]]); }
            const cannonFaces = tempFaces.map(tri => tri.map(i => {
                const v = new THREE.Vector3().fromBufferAttribute(pos, i);
                return pointsMap[`${v.x.toFixed(3)},${v.y.toFixed(3)},${v.z.toFixed(3)}`];
            }));
            const logicalFaces = [];
            tempFaces.forEach(tri => {
                const a = new THREE.Vector3().fromBufferAttribute(pos, tri[0]);
                const b = new THREE.Vector3().fromBufferAttribute(pos, tri[1]);
                const c = new THREE.Vector3().fromBufferAttribute(pos, tri[2]);
                const center = new THREE.Vector3().add(a).add(b).add(c).multiplyScalar(1/3);
                const cb = new THREE.Vector3().subVectors(c, b);
                const ab = new THREE.Vector3().subVectors(a, b);
                const normal = new THREE.Vector3().crossVectors(cb, ab).normalize();
                const threshold = (sides === 10) ? 0.95 : 0.99;
                const existing = logicalFaces.find(lf => lf.normal.dot(normal) > threshold);
                if (existing) { existing.centerAcc.add(center); existing.count++; } 
                else { logicalFaces.push({ normal: normal.clone(), centerAcc: center.clone(), count: 1 }); }
            });
            logicalFaces.forEach(f => f.center = f.centerAcc.divideScalar(f.count));
            return { shape: new CANNON.ConvexPolyhedron({ vertices, faces: cannonFaces }), faces: logicalFaces };
        }

        function addDecals(group, faces) {
            faces.forEach((data, index) => {
                const num = index + 1; data.value = num;
                const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = 'white'; ctx.font = 'bold 40px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                ctx.fillText(num, 32, 32);
                const plane = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.8), new THREE.MeshBasicMaterial({ map: new THREE.CanvasTexture(canvas), transparent: true, polygonOffset: true, polygonOffsetFactor: -1 }));
                plane.position.copy(data.center).add(data.normal.clone().multiplyScalar(0.01));
                plane.lookAt(data.center.clone().add(data.normal)); group.add(plane);
            });
        }

        function setupInteractions() {
            document.querySelectorAll('.die-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.die-btn').forEach(b => b.classList.remove('active'));
                    e.target.classList.add('active'); spawnDie(parseInt(e.target.dataset.sides));
                    document.getElementById('result-display').classList.remove('visible');
                });
            });
            document.getElementById('roll-btn').addEventListener('click', rollDice);
            const drop = document.getElementById('color-dropdown');
            const mainBtn = document.getElementById('current-color-btn');
            mainBtn.addEventListener('click', (e) => { e.stopPropagation(); drop.classList.toggle('open'); });
            document.addEventListener('click', () => drop.classList.remove('open'));
            document.querySelectorAll('.color-option').forEach(opt => {
                opt.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const col = parseInt(e.target.dataset.color);
                    const cssCol = e.target.style.background;
                    CONFIG.colors.die = col; mainBtn.style.background = cssCol;
                    document.getElementById('roll-btn').style.background = cssCol;
                    if(STATE.dieMesh) STATE.dieMesh.children[0].material.color.setHex(col);
                    drop.classList.remove('open');
                });
            });
        }

        function rollDice() {
            if(STATE.isRolling || !STATE.dieBody) return;
            STATE.isRolling = true; document.getElementById('roll-btn').disabled = true;
            document.getElementById('result-display').classList.remove('visible');
            STATE.dieBody.position.set(0, 6, 0); STATE.dieBody.velocity.set(0,0,0);
            STATE.dieBody.angularVelocity.set(0,0,0);
            const kick = 10, spin = 20;
            STATE.dieBody.applyImpulse(new CANNON.Vec3((Math.random()-.5)*kick, -5, (Math.random()-.5)*kick), new CANNON.Vec3(0,0,0));
            STATE.dieBody.angularVelocity.set((Math.random()-.5)*spin, (Math.random()-.5)*spin, (Math.random()-.5)*spin);
            const interval = setInterval(() => {
                const v = STATE.dieBody.velocity.length(); const w = STATE.dieBody.angularVelocity.length();
                if(v < 0.1 && w < 0.1 && STATE.dieBody.position.y < 3) { clearInterval(interval); showResult(); }
            }, 100);
        }

        function showResult() {
            STATE.isRolling = false; document.getElementById('roll-btn').disabled = false;
            const quat = new THREE.Quaternion().copy(STATE.dieBody.quaternion);
            let bestDot = -Infinity, result = 1;
            const targetDir = (STATE.currentSides === 4) ? new THREE.Vector3(0,-1,0) : new THREE.Vector3(0,1,0);
            STATE.logicalFaces.forEach(f => {
                const dot = f.normal.clone().applyQuaternion(quat).dot(targetDir);
                if(dot > bestDot) { bestDot = dot; result = f.value; }
            });
            const disp = document.getElementById('result-display');
            disp.innerText = result; disp.style.color = (result === STATE.currentSides) ? CONFIG.colors.gold : (result === 1) ? CONFIG.colors.red : CONFIG.colors.dark;
            disp.classList.add('visible');
            if (window.handleDiceResult) window.handleDiceResult(result);
        }

        function animate() {
            requestAnimationFrame(animate); STATE.world.step(1/60);
            if(STATE.dieBody && STATE.dieMesh) { STATE.dieMesh.position.copy(STATE.dieBody.position); STATE.dieMesh.quaternion.copy(STATE.dieBody.quaternion); }
            STATE.renderer.render(STATE.scene, STATE.camera);
        }
        init();
    </script>
</body>
</html>
